---
phase: 03-customer-portal-status-tracker
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/03_customer_portal_access.sql
  - supabase/migrations/README.md
  - services/registrationService.ts
  - types.ts
autonomous: true

must_haves:
  truths:
    - "Registration record has access_token generated at creation"
    - "Token expires 30 days after sticker delivered"
    - "Customer can fetch registration by orderId + token combination"
    - "Expired or invalid tokens return null (not error)"
  artifacts:
    - path: "supabase/migrations/03_customer_portal_access.sql"
      provides: "Token columns, expiry trigger, RLS policy update"
      contains: "access_token"
    - path: "services/registrationService.ts"
      provides: "Token-based lookup function"
      exports: ["getRegistrationByAccessKey"]
    - path: "types.ts"
      provides: "Updated Registration interface with token and body type"
      contains: "accessToken"
  key_links:
    - from: "services/registrationService.ts"
      to: "supabase registrations table"
      via: "getRegistrationByAccessKey query"
      pattern: "eq.*access_token"
---

<objective>
Add token-based access infrastructure for customer registration tracking.

Purpose: Enable secure, link-based access to registration status without requiring customer login. Tokens auto-generate at registration creation and expire 30 days after delivery.

Output: Database migration with token columns and trigger, service function for token-based lookup, updated TypeScript types.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-customer-portal-status-tracker/03-CONTEXT.md
@.planning/phases/03-customer-portal-status-tracker/03-RESEARCH.md
@triple-j-auto-investment-main/supabase/migrations/README.md
@triple-j-auto-investment-main/services/registrationService.ts
@triple-j-auto-investment-main/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token access migration</name>
  <files>
    supabase/migrations/03_customer_portal_access.sql
    supabase/migrations/README.md
  </files>
  <action>
Create SQL migration file `supabase/migrations/03_customer_portal_access.sql` with:

1. **New columns on registrations table:**
   - `access_token VARCHAR(32) NOT NULL DEFAULT encode(gen_random_bytes(16), 'hex')` - 32-char hex token
   - `token_expires_at TIMESTAMPTZ` - NULL until sticker delivered
   - `vehicle_body_type VARCHAR(50)` - 'sedan', 'suv', 'truck', 'hatchback', etc.

2. **Trigger for token expiry:**
   ```sql
   CREATE OR REPLACE FUNCTION set_token_expiry_on_delivery()
   RETURNS TRIGGER AS $$
   BEGIN
     IF NEW.current_stage = 'sticker_delivered' AND
        (OLD.current_stage IS NULL OR OLD.current_stage != 'sticker_delivered') THEN
       NEW.token_expires_at := NOW() + INTERVAL '30 days';
     END IF;
     RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;

   CREATE TRIGGER registration_set_token_expiry
   BEFORE UPDATE ON public.registrations
   FOR EACH ROW EXECUTE FUNCTION set_token_expiry_on_delivery();
   ```

3. **Update RLS policy for token-based access:**
   ```sql
   -- Drop existing public policy
   DROP POLICY IF EXISTS "Public can view registration by order_id" ON public.registrations;

   -- New policy requires valid (non-expired) token
   CREATE POLICY "Public can view registration by valid token" ON public.registrations
     FOR SELECT TO anon
     USING (
       token_expires_at IS NULL OR token_expires_at > NOW()
     );
   ```

4. **Backfill existing records:**
   ```sql
   UPDATE public.registrations
   SET access_token = encode(gen_random_bytes(16), 'hex')
   WHERE access_token IS NULL;
   ```

Update README.md to document migration 03 with breaking change note: public SELECT now requires valid token (not just order_id).
  </action>
  <verify>
Run `npx supabase migration list` or check file exists with correct structure.
Verify trigger function created with `\df set_token_expiry_on_delivery` in psql.
  </verify>
  <done>
Migration file exists with all 4 components. README updated with migration 03 entry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add token-based lookup service function</name>
  <files>
    services/registrationService.ts
    types.ts
  </files>
  <action>
**In types.ts:**

1. Add new fields to Registration interface (after `plateNumber`):
   ```typescript
   // Token-based access
   accessToken: string;
   tokenExpiresAt?: string;

   // Vehicle type for icon
   vehicleBodyType?: string;
   ```

**In services/registrationService.ts:**

1. Update `transformRegistration` function to map new fields:
   ```typescript
   accessToken: row.access_token,
   tokenExpiresAt: row.token_expires_at,
   vehicleBodyType: row.vehicle_body_type,
   ```

2. Add helper function to parse access key:
   ```typescript
   /**
    * Parse access key from URL into orderId and token components.
    * Format: TJ-YYYY-NNNN-{32-char-hex}
    * Example: TJ-2026-0001-a1b2c3d4e5f67890a1b2c3d4e5f67890
    */
   export function parseAccessKey(accessKey: string): { orderId: string; token: string } | null {
     // Order ID format: TJ-YYYY-NNNN (13 chars) + hyphen + 32 hex chars
     const match = accessKey.match(/^(TJ-\d{4}-\d{4})-([a-f0-9]{32})$/i);
     if (!match) return null;
     return { orderId: match[1].toUpperCase(), token: match[2].toLowerCase() };
   }
   ```

3. Add token-based lookup function:
   ```typescript
   /**
    * Fetch registration by orderId + access token combination.
    * Returns null for invalid token, expired token, or not found.
    * Used by customer portal for secure link-based access.
    */
   export async function getRegistrationByAccessKey(
     orderId: string,
     token: string
   ): Promise<Registration | null> {
     const { data, error } = await supabase
       .from('registrations')
       .select('*')
       .eq('order_id', orderId.toUpperCase())
       .eq('access_token', token.toLowerCase())
       .eq('is_archived', false)
       .single();

     if (error || !data) {
       // Token invalid or not found - return null, not error
       return null;
     }

     // Check expiry in application code (belt + suspenders with RLS)
     if (data.token_expires_at && new Date(data.token_expires_at) < new Date()) {
       return null;
     }

     return transformRegistration(data);
   }
   ```

4. Add helper to generate tracking link:
   ```typescript
   /**
    * Generate customer tracking link for a registration.
    * Format: /track/{orderId}-{token}
    */
   export function getTrackingLink(registration: Registration): string {
     return `/track/${registration.orderId}-${registration.accessToken}`;
   }
   ```

Ensure all new functions are exported.
  </action>
  <verify>
Run `npm run build` - should complete without TypeScript errors.
Verify exports: `grep -n "export.*getRegistrationByAccessKey\|parseAccessKey\|getTrackingLink" services/registrationService.ts`
  </verify>
  <done>
Types updated with 3 new fields. Service has parseAccessKey, getRegistrationByAccessKey, and getTrackingLink functions exported.
  </done>
</task>

</tasks>

<verification>
- [ ] Migration file `03_customer_portal_access.sql` exists with token columns, trigger, RLS update
- [ ] README.md documents migration 03 with breaking change note
- [ ] types.ts Registration interface has accessToken, tokenExpiresAt, vehicleBodyType fields
- [ ] registrationService.ts has parseAccessKey, getRegistrationByAccessKey, getTrackingLink exports
- [ ] `npm run build` passes without errors
</verification>

<success_criteria>
1. Database migration ready to apply with token infrastructure
2. Service functions enable token-based registration lookup
3. Tracking link generation available for admin UI integration
4. Build passes with updated types
</success_criteria>

<output>
After completion, create `.planning/phases/03-customer-portal-status-tracker/03-01-SUMMARY.md`
</output>
