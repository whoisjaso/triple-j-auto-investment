---
phase: 01-reliability-stability
plan: 04
type: execute
wave: 2
depends_on: [01-03]
files_modified:
  - triple-j-auto-investment-main/context/AuthContext.tsx
  - triple-j-auto-investment-main/context/Store.tsx
  - triple-j-auto-investment-main/App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "AuthContext exists with user state, login, logout, triggerRecovery functions"
    - "AuthContext is under 300 lines"
    - "Store.tsx no longer contains auth logic (delegates to AuthContext)"
    - "Login page and admin pages continue working"
  artifacts:
    - path: "triple-j-auto-investment-main/context/AuthContext.tsx"
      provides: "Auth state and methods extracted from Store.tsx"
      min_lines: 80
      max_lines: 300
      exports: ["AuthProvider", "useAuth"]
    - path: "triple-j-auto-investment-main/context/Store.tsx"
      provides: "Reduced Store without auth logic"
      contains: "useAuth"
  key_links:
    - from: "triple-j-auto-investment-main/context/Store.tsx"
      to: "triple-j-auto-investment-main/context/AuthContext.tsx"
      via: "useAuth hook for user state"
      pattern: "import.*useAuth.*from.*AuthContext"
    - from: "triple-j-auto-investment-main/App.tsx"
      to: "triple-j-auto-investment-main/context/AuthContext.tsx"
      via: "AuthProvider wrapping app"
      pattern: "import.*AuthProvider"
---

<objective>
Extract authentication logic from Store.tsx into AuthContext.tsx (STAB-03 Part 1).

Purpose: Store.tsx is 888 lines - a maintenance nightmare. Auth logic is the cleanest to extract first as it has minimal dependencies on other Store state. After extraction, AuthContext should be under 300 lines.

Output:
- AuthContext.tsx with user state, login, logout, session management
- Store.tsx importing user from AuthContext instead of managing it
- All existing auth consumers continue working
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-reliability-stability/01-03-SUMMARY.md

# Current Store.tsx with auth logic to extract
@triple-j-auto-investment-main/context/Store.tsx
@triple-j-auto-investment-main/lib/auth.ts
@triple-j-auto-investment-main/types.ts

# Files that use auth
@triple-j-auto-investment-main/pages/Login.tsx
@triple-j-auto-investment-main/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext.tsx with extracted auth logic</name>
  <files>triple-j-auto-investment-main/context/AuthContext.tsx</files>
  <action>
Create a new AuthContext.tsx by extracting auth-related code from Store.tsx:

```typescript
import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';
import { User } from '../types';
import { supabase } from '../supabase/config';
import { authService } from '../lib/auth';

interface AuthContextType {
  user: User | null;
  isAuthLoading: boolean;
  login: (email: string, password?: string) => Promise<boolean>;
  logout: () => Promise<void>;
  triggerRecovery: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isAuthLoading, setIsAuthLoading] = useState(true);
  const isInitializedRef = useRef(false);

  // Initialize auth session
  useEffect(() => {
    if (isInitializedRef.current) return;
    isInitializedRef.current = true;

    console.log('Initializing Auth Context...');

    // CACHE BUSTER: Check if user needs a hard refresh
    const lastBuildVersion = '2025-12-28-v2'; // Match Store.tsx version
    const cachedVersion = localStorage.getItem('tj_build_version');
    if (cachedVersion && cachedVersion !== lastBuildVersion) {
      console.warn('New version detected! Clearing old cached state...');
      localStorage.removeItem('supabase.auth.token');
      localStorage.setItem('tj_build_version', lastBuildVersion);
      if (typeof window !== 'undefined' && !window.location.search.includes('refreshed=1')) {
        console.log('Forcing hard refresh for new version...');
        window.location.href = window.location.pathname + '?refreshed=1';
        return;
      }
    }
    localStorage.setItem('tj_build_version', lastBuildVersion);

    // Verify Session First
    console.log("Verifying Identity Protocol...");
    authService.getSession().then(sessionUser => {
      if (sessionUser) {
        setUser({ email: sessionUser.email, isAdmin: sessionUser.isAdmin });
        console.log("Session restored:", sessionUser.email);
      } else {
        console.log("No active session found. Operating in public mode.");
      }
      setIsAuthLoading(false);
    }).catch(err => {
      console.error("Auth Session Check Failed:", err);
      setIsAuthLoading(false);
    });

    // Setup auth state listener
    const authListener = authService.onAuthStateChange(sessionUser => {
      if (sessionUser) {
        setUser({ email: sessionUser.email, isAdmin: sessionUser.isAdmin });
      } else {
        setUser(null);
      }
    });

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  const login = async (email: string, password?: string): Promise<boolean> => {
    if (!password) return false;

    console.log('Authenticating with Supabase...');

    const authUser = await authService.login(email, password);
    if (authUser) {
      setUser({ email: authUser.email, isAdmin: authUser.isAdmin });
      console.log('Login successful:', authUser.email);
      return true;
    }

    console.error('Login failed');
    return false;
  };

  const logout = async (): Promise<void> => {
    console.log('Logging out...');
    await authService.logout();
    setUser(null);
    console.log('Logout successful');
  };

  const triggerRecovery = () => {
    console.log("Security Alert: Unauthorized access attempt. Email dispatched.");
  };

  return (
    <AuthContext.Provider value={{
      user,
      isAuthLoading,
      login,
      logout,
      triggerRecovery,
    }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export default AuthProvider;
```

This extracts:
- user state management
- login/logout/triggerRecovery functions
- Session initialization and auth listener
- Cache buster logic (shared with Store for now)

The file should be around 120 lines, well under the 300 line target.
  </action>
  <verify>
- File exists at `triple-j-auto-investment-main/context/AuthContext.tsx`
- `wc -l triple-j-auto-investment-main/context/AuthContext.tsx` shows under 300 lines
- `grep "useAuth" triple-j-auto-investment-main/context/AuthContext.tsx` shows export
- `npx tsc --noEmit` passes
  </verify>
  <done>AuthContext.tsx exists with user state, login, logout, triggerRecovery under 300 lines</done>
</task>

<task type="auto">
  <name>Task 2: Update Store.tsx to use AuthContext</name>
  <files>triple-j-auto-investment-main/context/Store.tsx</files>
  <action>
Modify Store.tsx to delegate auth to AuthContext:

1. **Add import for useAuth**:
```typescript
import { useAuth } from './AuthContext';
```

2. **Remove auth-related state declarations** (around line 144):
Remove:
```typescript
const [user, setUser] = useState<User | null>(null);
```

3. **Get user from useAuth** instead. Add near the top of StoreProvider:
```typescript
const { user } = useAuth();
```

4. **Remove the entire auth initialization block** from the useEffect (lines 154-199 approximately).
This includes:
- Session check (`authService.getSession()`)
- Auth state listener (`authService.onAuthStateChange()`)
- Cache buster logic (moved to AuthContext)

Keep only the data loading and subscription parts:
```typescript
useEffect(() => {
  if (isInitializedRef.current) return;
  isInitializedRef.current = true;

  console.log('Initializing Triple J Command Center with Supabase...');

  // Load data from Supabase
  const initializeData = async () => {
    await loadVehicles();
    await loadLeads();
    console.log("Auto-sync disabled. Use manual sync in admin panel if needed.");
  };

  initializeData();

  // Setup real-time subscriptions
  const vehicleSubscription = supabase
    .channel('vehicles_changes')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'vehicles' }, () => {
      console.log('Vehicle data changed, reloading...');
      loadVehicles();
    })
    .subscribe();

  const leadSubscription = supabase
    .channel('leads_changes')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'leads' }, () => {
      console.log('Lead data changed, reloading...');
      loadLeads();
    })
    .subscribe();

  return () => {
    vehicleSubscription.unsubscribe();
    leadSubscription.unsubscribe();
  };
}, []);
```

5. **Remove login, logout, triggerRecovery function definitions** (lines 347-372).
These are now in AuthContext.

6. **Update StoreContextType interface** - remove auth-related fields since they come from useAuth:
```typescript
interface StoreContextType {
  vehicles: Vehicle[];
  leads: Lead[];
  // REMOVED: user, login, logout, triggerRecovery - now in AuthContext
  lastSync: Date | null;
  isLoading: boolean;
  hasLoaded: boolean;
  connectionError: string | null;
  lastError: AppError | null;
  clearLastError: () => void;
  refreshVehicles: () => Promise<void>;
  addVehicle: (v: Vehicle) => Promise<void>;
  updateVehicle: (id: string, v: Partial<Vehicle>) => Promise<void>;
  removeVehicle: (id: string) => Promise<void>;
  syncWithGoogleSheets: (silent?: boolean) => Promise<string>;
  addLead: (l: Lead) => Promise<void>;
  updateRegistration: (id: string, status: string) => Promise<void>;
  resetToDefault: () => void;
}
```

7. **Update Provider value** to remove auth fields (around line 858-878):
Remove: `user`, `login`, `logout`, `triggerRecovery` from the Provider value.

8. **Keep user references** in addVehicle/updateVehicle/removeVehicle for logging.
Since we have `const { user } = useAuth()` at the top, the user variable is still available for console.log statements.

**IMPORTANT:** Do NOT modify the vehicle CRUD functions (addVehicle, updateVehicle, removeVehicle) except to ensure they still work. The session verification inside those functions uses supabase.auth.getSession() directly, which is fine.
  </action>
  <verify>
- `grep "login:" triple-j-auto-investment-main/context/Store.tsx` returns no results (moved to AuthContext)
- `grep "useAuth" triple-j-auto-investment-main/context/Store.tsx` shows import and usage
- `grep "setUser" triple-j-auto-investment-main/context/Store.tsx` returns no results (user state moved)
- `npx tsc --noEmit` passes
- `wc -l triple-j-auto-investment-main/context/Store.tsx` shows reduced line count
  </verify>
  <done>Store.tsx delegates auth to AuthContext, auth logic removed (~100 lines saved)</done>
</task>

<task type="auto">
  <name>Task 3: Wire AuthProvider into App.tsx and update consumers</name>
  <files>triple-j-auto-investment-main/App.tsx</files>
  <action>
Update App.tsx to include AuthProvider in the provider hierarchy:

1. **Add import**:
```typescript
import { AuthProvider } from './context/AuthContext';
```

2. **Update provider order**. AuthProvider must wrap StoreProvider since Store uses useAuth:

```tsx
// Provider order from outside to inside:
<ErrorProvider showAdminDetails={true}>
  <AuthProvider>
    <StoreProvider>
      <BrowserRouter>
        {/* routes */}
      </BrowserRouter>
    </StoreProvider>
  </AuthProvider>
</ErrorProvider>
```

3. **Check if any routes reference useStore for auth fields**.
Common patterns to look for and update:
- `const { user, login, logout } = useStore();`
- Should become: `const { user, login, logout } = useAuth();`

Look in these files (update if needed):
- Login.tsx (likely uses login)
- Dashboard.tsx (likely uses user, logout)
- Any admin pages that check user.isAdmin

For now, just update App.tsx. The consumers will be updated to use useAuth in a follow-up task if TypeScript compilation fails.
  </action>
  <verify>
- `grep "AuthProvider" triple-j-auto-investment-main/App.tsx` shows import and usage
- `npx tsc --noEmit` passes (may require updating consumers)
  </verify>
  <done>AuthProvider wraps StoreProvider, auth is available throughout the app</done>
</task>

</tasks>

<verification>
1. AuthContext.tsx exists with useAuth export
2. AuthContext.tsx is under 300 lines
3. Store.tsx no longer defines login/logout/triggerRecovery
4. Store.tsx uses useAuth() to get user
5. App.tsx has AuthProvider wrapping StoreProvider
6. `npx tsc --noEmit` passes

If TypeScript fails due to consumers:
- Update Login.tsx to use useAuth
- Update admin pages to use useAuth
- Update any component using useStore().user to use useAuth().user
</verification>

<success_criteria>
- AuthContext.tsx exists and exports useAuth hook
- AuthContext is under 300 lines (target ~120)
- Store.tsx delegates auth to AuthContext
- Store.tsx is reduced by ~100 lines
- Login and admin pages continue to function
</success_criteria>

<output>
After completion, create `.planning/phases/01-reliability-stability/01-04-SUMMARY.md`
</output>
