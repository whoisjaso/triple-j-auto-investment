---
phase: 01-reliability-stability
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - triple-j-auto-investment-main/context/Store.tsx
  - triple-j-auto-investment-main/components/ErrorProvider.tsx
  - triple-j-auto-investment-main/App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Database errors display in ErrorModal instead of browser alert()"
    - "useRetry hook provides auto-retry for failed operations"
    - "ErrorModal shows user-friendly message with retry button for retryable errors"
  artifacts:
    - path: "triple-j-auto-investment-main/components/ErrorProvider.tsx"
      provides: "Context provider wrapping ErrorModal and error state"
      min_lines: 50
      exports: ["ErrorProvider", "useErrorContext"]
    - path: "triple-j-auto-investment-main/App.tsx"
      provides: "ErrorProvider wrapped around StoreProvider"
      contains: "ErrorProvider"
  key_links:
    - from: "triple-j-auto-investment-main/components/ErrorProvider.tsx"
      to: "triple-j-auto-investment-main/components/ErrorModal.tsx"
      via: "ErrorModal component usage"
      pattern: "import.*ErrorModal"
    - from: "triple-j-auto-investment-main/App.tsx"
      to: "triple-j-auto-investment-main/components/ErrorProvider.tsx"
      via: "ErrorProvider wrapping app"
      pattern: "import.*ErrorProvider"
---

<objective>
Wire the orphaned ErrorModal and useRetry into the error handling flow.

Purpose: Plans 01-01 created ErrorModal.tsx and useRetry.ts but they were never integrated. Store.tsx still uses alert() for errors. This plan connects the infrastructure to the actual error handling.

Output:
- ErrorProvider context for app-wide error display
- Store.tsx using useRetry for vehicle operations
- ErrorModal displaying instead of alert() calls
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-reliability-stability/01-01-SUMMARY.md

# Error handling infrastructure (already built but orphaned)
@triple-j-auto-investment-main/components/ErrorModal.tsx
@triple-j-auto-investment-main/hooks/useRetry.ts
@triple-j-auto-investment-main/types.ts

# File to wire the error handling into
@triple-j-auto-investment-main/context/Store.tsx
@triple-j-auto-investment-main/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorProvider context for app-wide error handling</name>
  <files>triple-j-auto-investment-main/components/ErrorProvider.tsx</files>
  <action>
Create a new ErrorProvider component that wraps ErrorModal and provides error state to the app:

```typescript
import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import { ErrorModal } from './ErrorModal';
import { useRetry } from '../hooks/useRetry';
import { AppError } from '../types';

interface ErrorContextType {
  showError: (error: AppError) => void;
  clearError: () => void;
  currentError: AppError | null;
  // Expose retry functionality for consumers
  retry: ReturnType<typeof useRetry>;
}

const ErrorContext = createContext<ErrorContextType | undefined>(undefined);

interface ErrorProviderProps {
  children: ReactNode;
  showAdminDetails?: boolean;
}

export const ErrorProvider: React.FC<ErrorProviderProps> = ({
  children,
  showAdminDetails = false
}) => {
  const [currentError, setCurrentError] = useState<AppError | null>(null);

  const retry = useRetry({
    maxAttempts: 3,
    baseDelay: 1000,
    onMaxAttemptsReached: (error) => {
      setCurrentError(error);
    },
  });

  const showError = useCallback((error: AppError) => {
    setCurrentError(error);
  }, []);

  const clearError = useCallback(() => {
    setCurrentError(null);
    retry.reset();
  }, [retry]);

  const handleRetry = useCallback(() => {
    // Clear error and let the consumer re-trigger the operation
    setCurrentError(null);
  }, []);

  return (
    <ErrorContext.Provider value={{ showError, clearError, currentError, retry }}>
      {children}
      <ErrorModal
        error={currentError}
        onClose={clearError}
        onRetry={currentError?.retryable ? handleRetry : undefined}
        isRetrying={retry.state.isRetrying}
        retryCountdown={retry.state.countdown}
        retryAttempt={retry.state.attempt}
        maxAttempts={retry.state.maxAttempts}
        showAdminDetails={showAdminDetails}
      />
    </ErrorContext.Provider>
  );
};

export const useErrorContext = (): ErrorContextType => {
  const context = useContext(ErrorContext);
  if (!context) {
    throw new Error('useErrorContext must be used within ErrorProvider');
  }
  return context;
};

export default ErrorProvider;
```

This creates a clean separation: ErrorProvider manages the modal state, while consumers can trigger errors via `showError()`.
  </action>
  <verify>
- File exists at `triple-j-auto-investment-main/components/ErrorProvider.tsx`
- `grep "ErrorProvider" triple-j-auto-investment-main/components/ErrorProvider.tsx` shows export
- `grep "useErrorContext" triple-j-auto-investment-main/components/ErrorProvider.tsx` shows export
- `npx tsc --noEmit` passes
  </verify>
  <done>ErrorProvider context exists with showError/clearError functions and ErrorModal integration</done>
</task>

<task type="auto">
  <name>Task 2: Wire ErrorProvider into App.tsx</name>
  <files>triple-j-auto-investment-main/App.tsx</files>
  <action>
Update App.tsx to wrap the app with ErrorProvider.

1. **Add import** at the top of App.tsx:

```typescript
import { ErrorProvider } from './components/ErrorProvider';
```

2. **Wrap the app with ErrorProvider**. Find the root component structure and wrap it:

The ErrorProvider should wrap around the StoreProvider (or be inside it, depending on whether Store needs error context).

Since Store.tsx will use showError to replace alert(), ErrorProvider needs to be OUTSIDE StoreProvider so Store can access it.

Look for the existing provider structure (likely StoreProvider wrapping BrowserRouter or similar) and add ErrorProvider as the outermost wrapper:

```tsx
// Before (example structure):
<StoreProvider>
  <BrowserRouter>
    {/* routes */}
  </BrowserRouter>
</StoreProvider>

// After:
<ErrorProvider showAdminDetails={true}>
  <StoreProvider>
    <BrowserRouter>
      {/* routes */}
    </BrowserRouter>
  </StoreProvider>
</ErrorProvider>
```

Note: showAdminDetails={true} because this is an admin dashboard app where technical details are helpful.
  </action>
  <verify>
- `grep "ErrorProvider" triple-j-auto-investment-main/App.tsx` shows import and usage
- `npx tsc --noEmit` passes
- App still renders (run dev server briefly if needed)
  </verify>
  <done>ErrorProvider wraps the app and is available to all components including Store</done>
</task>

<task type="auto">
  <name>Task 3: Replace alert() calls in Store.tsx with ErrorModal</name>
  <files>triple-j-auto-investment-main/context/Store.tsx</files>
  <action>
Update Store.tsx to use ErrorProvider instead of alert() for error display.

**IMPORTANT:** Since Store.tsx is a context provider, it cannot directly use useErrorContext (contexts cannot use other contexts at the same level). Instead, we need to:

1. **Add an error state to Store** and let consumers display via ErrorModal:

Add these to StoreContextType interface:
```typescript
interface StoreContextType {
  // ... existing fields ...
  lastError: AppError | null;
  clearLastError: () => void;
}
```

2. **Add state in StoreProvider**:
```typescript
import { AppError, ErrorCodes } from '../types';

// In StoreProvider:
const [lastError, setLastError] = useState<AppError | null>(null);

const clearLastError = useCallback(() => {
  setLastError(null);
}, []);
```

3. **Create a helper function** to convert errors to AppError:
```typescript
const createAppError = (code: string, message: string, details?: string): AppError => ({
  code,
  message,
  details,
  timestamp: new Date(),
  retryable: ![ErrorCodes.RLS_NOT_ADMIN, ErrorCodes.DB_DUPLICATE].includes(code as any),
});
```

4. **Replace alert() calls** with setLastError():

In `addVehicle` (around lines 380-450):
- Replace `alert('... ADD FAILED: You are not logged in!...')` with:
  ```typescript
  setLastError(createAppError(ErrorCodes.RLS_NO_SESSION, 'You are not logged in. Please log in again.'));
  ```
- Replace `alert('... ADD FAILED: Your account is not set as admin...')` with:
  ```typescript
  setLastError(createAppError(ErrorCodes.RLS_NOT_ADMIN, 'You do not have admin permissions.'));
  ```
- Replace `alert('... Images are too large...')` with:
  ```typescript
  setLastError(createAppError(ErrorCodes.DB_CONSTRAINT, 'Images are too large. Try smaller images (under 500KB).'));
  ```
- And so on for other alert() calls in addVehicle.

In `updateVehicle` (around lines 456-555):
- Replace `alert('UPDATE FAILED...')` calls with appropriate setLastError() calls.

In `removeVehicle` (around lines 558-591):
- Replace `alert('DELETE FAILED...')` calls with appropriate setLastError() calls.

In `addLead` (around lines 794-832):
- Replace `alert('Failed to save lead...')` with:
  ```typescript
  setLastError(createAppError(ErrorCodes.DB_UNKNOWN, 'Failed to save lead. Please try again.', error?.message));
  ```

5. **Add to Provider value**:
```typescript
<StoreContext.Provider value={{
  // ... existing values ...
  lastError,
  clearLastError,
}}>
```

**Do NOT remove console.error() calls** - those are useful for debugging. Only replace the user-facing alert() calls.
  </action>
  <verify>
- `grep "alert(" triple-j-auto-investment-main/context/Store.tsx` returns minimal or no results (some may remain for edge cases)
- `grep "lastError" triple-j-auto-investment-main/context/Store.tsx` shows state and usage
- `grep "createAppError" triple-j-auto-investment-main/context/Store.tsx` shows helper function
- `npx tsc --noEmit` passes
  </verify>
  <done>Store.tsx uses lastError state instead of alert() for error display</done>
</task>

</tasks>

<verification>
1. ErrorProvider component exists and exports useErrorContext
2. App.tsx has ErrorProvider wrapping the app
3. Store.tsx has lastError state and clearLastError function
4. Most alert() calls in Store.tsx replaced with setLastError()
5. `npx tsc --noEmit` passes

Manual verification:
- Trigger an error (e.g., try to update without being logged in)
- ErrorModal should appear instead of browser alert
</verification>

<success_criteria>
- ErrorProvider context wraps the app
- Store.tsx exposes lastError for components to display via ErrorModal
- alert() calls replaced with structured AppError objects
- Error handling infrastructure is now wired and functional
</success_criteria>

<output>
After completion, create `.planning/phases/01-reliability-stability/01-03-SUMMARY.md`
</output>
