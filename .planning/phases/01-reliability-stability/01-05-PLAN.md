---
phase: 01-reliability-stability
plan: 05
type: execute
wave: 2
depends_on: ["01-03", "01-04"]
files_modified:
  - triple-j-auto-investment-main/context/Store.tsx
  - triple-j-auto-investment-main/lib/store/index.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "useStore() returns IDENTICAL interface to before"
    - "All existing functionality works unchanged"
    - "No consumer code changes required"
    - "Store.tsx is under 300 lines"
  artifacts:
    - path: "triple-j-auto-investment-main/context/Store.tsx"
      provides: "Facade that imports modules and exposes useStore()"
      exports: ["StoreProvider", "useStore"]
      max_lines: 300
    - path: "triple-j-auto-investment-main/lib/store/index.ts"
      provides: "Barrel export for store modules"
      exports: ["vehicles", "sheets", "leads", "types"]
  key_links:
    - from: "context/Store.tsx"
      to: "lib/store/vehicles"
      via: "import { loadVehicles, addVehicle, ... }"
      pattern: "from.*lib/store"
    - from: "context/Store.tsx"
      to: "lib/store/sheets"
      via: "import { syncWithGoogleSheets, ... }"
      pattern: "from.*lib/store"
    - from: "context/Store.tsx"
      to: "lib/store/leads"
      via: "import { loadLeads, addLead }"
      pattern: "from.*lib/store"
---

<objective>
Integrate extracted modules into Store.tsx as facade, completing STAB-03 decomposition.

Purpose: Final step - Store.tsx becomes a thin orchestration layer that imports modules and provides the unchanged useStore() interface. Target: under 300 lines.

Output: Refactored Store.tsx that delegates to lib/store/* modules while keeping identical public interface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-reliability-stability/01-03-SUMMARY.md
@.planning/phases/01-reliability-stability/01-04-SUMMARY.md
@triple-j-auto-investment-main/context/Store.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/store/index.ts barrel export</name>
  <files>triple-j-auto-investment-main/lib/store/index.ts</files>
  <action>
Create `lib/store/index.ts` as barrel export:

```typescript
// Store modules - internal decomposition of Store.tsx
// Consumers should NOT import from here directly - use useStore() from context/Store.tsx

export * from './types';
export * from './vehicles';
export * from './sheets';
export * from './leads';
```

This allows Store.tsx to import from a single location.
  </action>
  <verify>File exists with re-exports from all modules</verify>
  <done>lib/store/index.ts barrel export created</done>
</task>

<task type="auto">
  <name>Task 2: Refactor Store.tsx to use extracted modules</name>
  <files>triple-j-auto-investment-main/context/Store.tsx</files>
  <action>
Rewrite Store.tsx to be a thin facade that:
1. Imports from lib/store modules
2. Manages React state
3. Creates wrapper functions that call module functions with state/setters
4. Exposes IDENTICAL StoreContextType interface

**CRITICAL CONSTRAINTS:**
- StoreContextType interface MUST NOT CHANGE (lines 11-29 of original)
- useStore() export MUST NOT CHANGE
- All methods must behave identically

**New Structure (~250 lines):**

```typescript
import React, { createContext, useContext, useState, ReactNode, useEffect, useRef } from 'react';
import { Vehicle, VehicleStatus, Lead, User } from '../types';
import { supabase } from '../supabase/config';
import { authService } from '../lib/auth';

// Import extracted modules
import {
  loadVehicles as loadVehiclesModule,
  addVehicle as addVehicleModule,
  updateVehicle as updateVehicleModule,
  removeVehicle as removeVehicleModule,
  FALLBACK_VEHICLES
} from '../lib/store/vehicles';
import {
  syncWithGoogleSheets as syncModule,
  GOOGLE_SHEET_URL
} from '../lib/store/sheets';
import {
  loadLeads as loadLeadsModule,
  addLead as addLeadModule
} from '../lib/store/leads';

// UNCHANGED: Context type interface (identical to original lines 11-29)
interface StoreContextType {
  vehicles: Vehicle[];
  leads: Lead[];
  user: User | null;
  lastSync: Date | null;
  isLoading: boolean;
  connectionError: string | null;
  refreshVehicles: () => Promise<void>;
  login: (email: string, password?: string) => Promise<boolean>;
  triggerRecovery: () => void;
  logout: () => Promise<void>;
  addVehicle: (v: Vehicle) => Promise<void>;
  updateVehicle: (id: string, v: Partial<Vehicle>) => Promise<void>;
  removeVehicle: (id: string) => Promise<void>;
  syncWithGoogleSheets: (silent?: boolean) => Promise<string>;
  addLead: (l: Lead) => Promise<void>;
  updateRegistration: (id: string, status: string) => Promise<void>;
  resetToDefault: () => void;
}

const StoreContext = createContext<StoreContextType | undefined>(undefined);

export const StoreProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // State declarations (same as before)
  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [leads, setLeads] = useState<Lead[]>([]);
  const [user, setUser] = useState<User | null>(null);
  const [lastSync, setLastSync] = useState<Date | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);

  const isSyncingRef = useRef(false);
  const isInitializedRef = useRef(false);

  // Wrapper that calls module with current state/setters
  const loadVehicles = async () => {
    await loadVehiclesModule(
      { setVehicles, setIsLoading, setConnectionError },
      vehicles,
      FALLBACK_VEHICLES
    );
  };

  const loadLeads = async () => {
    await loadLeadsModule(setLeads);
  };

  // Initialization effect (keep cache buster + auth + subscriptions from original)
  useEffect(() => {
    if (isInitializedRef.current) return;
    isInitializedRef.current = true;

    // [Copy lines 156-237 from original - cache buster, auth, subscriptions]
    // Just replace direct loadVehicles/loadLeads calls with the wrappers above
  }, []);

  // Auth functions (delegate to authService - unchanged from original)
  const login = async (email: string, password?: string): Promise<boolean> => {
    if (!password) return false;
    const authUser = await authService.login(email, password);
    if (authUser) {
      setUser({ email: authUser.email, isAdmin: authUser.isAdmin });
      return true;
    }
    return false;
  };

  const logout = async (): Promise<void> => {
    await authService.logout();
    setUser(null);
  };

  const triggerRecovery = () => {
    console.log("Security Alert: Unauthorized access attempt. Email dispatched.");
  };

  // Vehicle CRUD wrappers
  const addVehicle = async (v: Vehicle): Promise<void> => {
    await addVehicleModule(v, loadVehicles);
  };

  const updateVehicle = async (id: string, v: Partial<Vehicle>): Promise<void> => {
    await updateVehicleModule(id, v, user, loadVehicles);
  };

  const removeVehicle = async (id: string): Promise<void> => {
    await removeVehicleModule(id, loadVehicles);
  };

  // Sheets sync wrapper
  const syncWithGoogleSheets = async (silent: boolean = false): Promise<string> => {
    return syncModule(
      {
        isSyncingRef,
        vehicles,
        setLastSync,
        setVehicles,
        loadVehiclesFn: loadVehicles,
        fallbackVehicles: FALLBACK_VEHICLES
      },
      silent
    );
  };

  // Lead wrapper
  const addLead = async (l: Lead): Promise<void> => {
    await addLeadModule(l);
  };

  // Registration update (keep inline - only ~20 lines)
  const updateRegistration = async (id: string, status: string): Promise<void> => {
    // [Copy lines 840-860 from original exactly]
  };

  const resetToDefault = () => {
    if (window.confirm("DANGER: This will sync from Google Sheets...")) {
      syncWithGoogleSheets(false);
    }
  };

  // UNCHANGED: Provider value (identical shape to original)
  return (
    <StoreContext.Provider value={{
      vehicles,
      leads,
      user,
      lastSync,
      isLoading,
      connectionError,
      refreshVehicles: loadVehicles,
      login,
      triggerRecovery,
      logout,
      addVehicle,
      updateVehicle,
      removeVehicle,
      syncWithGoogleSheets,
      addLead,
      updateRegistration,
      resetToDefault
    }}>
      {children}
    </StoreContext.Provider>
  );
};

// UNCHANGED: Hook export (identical to original)
export const useStore = () => {
  const context = useContext(StoreContext);
  if (!context) throw new Error('useStore must be used within StoreProvider');
  return context;
};
```

**Key points:**
1. StoreContextType interface is BYTE-FOR-BYTE identical
2. useStore() export is BYTE-FOR-BYTE identical
3. All console.log messages preserved (they're in the modules now)
4. Initialization logic (cache buster, auth listener, subscriptions) stays in Store.tsx
5. Only the IMPLEMENTATIONS are delegated to modules
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `wc -l triple-j-auto-investment-main/context/Store.tsx` shows under 300 lines
3. Interface unchanged: grep for "interface StoreContextType" confirms same shape
4. NO changes to App.tsx or pages/*.tsx
  </verify>
  <done>
Store.tsx is under 300 lines and delegates to lib/store/* modules.
useStore() interface unchanged - consumers work without modification.
  </done>
</task>

</tasks>

<verification>
1. Line count: `wc -l context/Store.tsx` < 300
2. TypeScript: `npx tsc --noEmit` passes
3. Interface unchanged: StoreContextType has same 17 properties
4. NO UI changes: App.tsx, pages/*.tsx unmodified
5. Modules exist: lib/store/{vehicles,sheets,leads,types,index}.ts all present
</verification>

<success_criteria>
- Store.tsx under 300 lines (target: ~250)
- lib/store/ contains 5 files (types, vehicles, sheets, leads, index)
- Total extracted: vehicles (~280), sheets (~180), leads (~60) = ~520 lines
- TypeScript compilation passes
- NO changes to App.tsx or any pages/*.tsx files
- useStore() returns identical interface
</success_criteria>

<output>
After completion, create `.planning/phases/01-reliability-stability/01-05-SUMMARY.md`
</output>
