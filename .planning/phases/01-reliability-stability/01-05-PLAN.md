---
phase: 01-reliability-stability
plan: 05
type: execute
wave: 3
depends_on: [01-04]
files_modified:
  - triple-j-auto-investment-main/context/VehicleContext.tsx
  - triple-j-auto-investment-main/context/Store.tsx
  - triple-j-auto-investment-main/App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "VehicleContext exists with vehicle state, CRUD operations, and sync"
    - "VehicleContext is under 300 lines"
    - "Store.tsx is under 300 lines after extraction"
    - "Inventory page and admin pages continue working with vehicle operations"
  artifacts:
    - path: "triple-j-auto-investment-main/context/VehicleContext.tsx"
      provides: "Vehicle state and CRUD operations extracted from Store.tsx"
      min_lines: 200
      max_lines: 300
      exports: ["VehicleProvider", "useVehicles"]
    - path: "triple-j-auto-investment-main/context/Store.tsx"
      provides: "Reduced base Store with leads and sync"
      max_lines: 300
  key_links:
    - from: "triple-j-auto-investment-main/App.tsx"
      to: "triple-j-auto-investment-main/context/VehicleContext.tsx"
      via: "VehicleProvider wrapping app"
      pattern: "import.*VehicleProvider"
    - from: "triple-j-auto-investment-main/context/VehicleContext.tsx"
      to: "triple-j-auto-investment-main/context/AuthContext.tsx"
      via: "useAuth for user state in CRUD operations"
      pattern: "import.*useAuth"
---

<objective>
Extract vehicle logic from Store.tsx into VehicleContext.tsx (STAB-03 Part 2).

Purpose: After auth extraction, Store.tsx is still ~780 lines. Vehicle CRUD is the largest remaining concern (~400 lines). Extracting it brings Store.tsx under 300 lines and creates a focused VehicleContext.

Output:
- VehicleContext.tsx with vehicle state, CRUD, loading, and real-time subscriptions
- Store.tsx reduced to leads, sync, and base coordination (~200 lines)
- Both contexts under 300 lines each
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-reliability-stability/01-04-SUMMARY.md

# Store.tsx after auth extraction
@triple-j-auto-investment-main/context/Store.tsx
@triple-j-auto-investment-main/context/AuthContext.tsx
@triple-j-auto-investment-main/types.ts
@triple-j-auto-investment-main/supabase/config.ts

# Main consumers
@triple-j-auto-investment-main/pages/Inventory.tsx
@triple-j-auto-investment-main/pages/admin/Inventory.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VehicleContext.tsx with extracted vehicle logic</name>
  <files>triple-j-auto-investment-main/context/VehicleContext.tsx</files>
  <action>
Create VehicleContext.tsx by extracting vehicle-related code from Store.tsx:

```typescript
import React, { createContext, useContext, useState, useEffect, useRef, ReactNode, useCallback } from 'react';
import { Vehicle, VehicleStatus, AppError, ErrorCodes } from '../types';
import { supabase } from '../supabase/config';
import { useAuth } from './AuthContext';

// Fallback data (moved from Store.tsx)
const FALLBACK_ASSETS: Vehicle[] = [
  // ... copy the FALLBACK_ASSETS array from Store.tsx (lines 35-124) ...
];

interface VehicleContextType {
  vehicles: Vehicle[];
  isLoading: boolean;
  hasLoaded: boolean;
  connectionError: string | null;
  lastError: AppError | null;
  clearLastError: () => void;
  refreshVehicles: () => Promise<void>;
  addVehicle: (v: Vehicle) => Promise<void>;
  updateVehicle: (id: string, v: Partial<Vehicle>) => Promise<void>;
  removeVehicle: (id: string) => Promise<void>;
  updateRegistration: (id: string, status: string) => Promise<void>;
}

const VehicleContext = createContext<VehicleContextType | undefined>(undefined);

export const VehicleProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { user } = useAuth();

  const [vehicles, setVehicles] = useState<Vehicle[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [hasLoaded, setHasLoaded] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [lastError, setLastError] = useState<AppError | null>(null);

  const isInitializedRef = useRef(false);

  const clearLastError = useCallback(() => {
    setLastError(null);
  }, []);

  const createAppError = useCallback((code: string, message: string, details?: string): AppError => ({
    code,
    message,
    details,
    timestamp: new Date(),
    retryable: ![ErrorCodes.RLS_NOT_ADMIN, ErrorCodes.DB_DUPLICATE].includes(code as any),
  }), []);

  // Load vehicles from Supabase
  const loadVehicles = useCallback(async () => {
    if (!hasLoaded) {
      setIsLoading(true);
    }

    console.log('Loading vehicles from Supabase...');

    try {
      const abortController = new AbortController();
      const timeoutId = setTimeout(() => abortController.abort(), 10000);

      const { data, error } = await supabase
        .from('vehicles')
        .select('*')
        .abortSignal(abortController.signal);

      clearTimeout(timeoutId);

      if (error) {
        console.error('Failed to load vehicles:', error);
        setConnectionError(`Database Error: ${error.message}`);

        if (!hasLoaded && vehicles.length === 0) {
          console.warn('Using fallback assets due to fetch error.');
          setVehicles(FALLBACK_ASSETS);
        }
        setHasLoaded(true);
        setIsLoading(false);
        return;
      }

      setConnectionError(null);

      const transformed = (data || []).map((v: any) => ({
        id: v.id,
        vin: v.vin,
        make: v.make,
        model: v.model,
        year: v.year,
        price: v.price,
        cost: v.cost || 0,
        costTowing: v.cost_towing || 0,
        costMechanical: v.cost_mechanical || 0,
        costCosmetic: v.cost_cosmetic || 0,
        costOther: v.cost_other || 0,
        soldPrice: v.sold_price || undefined,
        soldDate: v.sold_date || undefined,
        mileage: v.mileage,
        status: v.status as VehicleStatus,
        description: v.description || '',
        imageUrl: v.image_url || '',
        gallery: v.gallery || [],
        diagnostics: v.diagnostics || [],
        registrationStatus: v.registration_status as any,
        registrationDueDate: v.registration_due_date || undefined,
        dateAdded: v.date_added,
      }));

      setVehicles(transformed);
      setHasLoaded(true);
      setIsLoading(false);

      console.log(`Loaded ${transformed.length} vehicles.`);
    } catch (error) {
      console.error('Unexpected error loading vehicles:', error);

      if (error instanceof Error && error.name === 'AbortError') {
        setConnectionError('Request timed out. Please try again.');
      }

      if (!hasLoaded && vehicles.length === 0) {
        setVehicles(FALLBACK_ASSETS);
      }

      setHasLoaded(true);
      setIsLoading(false);
    }
  }, [hasLoaded, vehicles.length]);

  // Initialize and subscribe to real-time updates
  useEffect(() => {
    if (isInitializedRef.current) return;
    isInitializedRef.current = true;

    loadVehicles();

    const vehicleSubscription = supabase
      .channel('vehicles_changes')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'vehicles' }, () => {
        console.log('Vehicle data changed, reloading...');
        loadVehicles();
      })
      .subscribe();

    return () => {
      vehicleSubscription.unsubscribe();
    };
  }, [loadVehicles]);

  // Copy addVehicle, updateVehicle, removeVehicle, updateRegistration from Store.tsx
  // Replace alert() calls with setLastError(createAppError(...))
  // Keep the existing session verification logic using supabase.auth.getSession()

  const addVehicle = async (v: Vehicle): Promise<void> => {
    // ... copy from Store.tsx lines 374-453, replacing alert() with setLastError()
  };

  const updateVehicle = async (id: string, updatedVehicle: Partial<Vehicle>): Promise<void> => {
    // ... copy from Store.tsx lines 456-555, replacing alert() with setLastError()
  };

  const removeVehicle = async (id: string): Promise<void> => {
    // ... copy from Store.tsx lines 558-591, replacing alert() with setLastError()
  };

  const updateRegistration = async (id: string, status: string): Promise<void> => {
    // ... copy from Store.tsx lines 835-856
  };

  return (
    <VehicleContext.Provider value={{
      vehicles,
      isLoading,
      hasLoaded,
      connectionError,
      lastError,
      clearLastError,
      refreshVehicles: loadVehicles,
      addVehicle,
      updateVehicle,
      removeVehicle,
      updateRegistration,
    }}>
      {children}
    </VehicleContext.Provider>
  );
};

export const useVehicles = (): VehicleContextType => {
  const context = useContext(VehicleContext);
  if (!context) {
    throw new Error('useVehicles must be used within VehicleProvider');
  }
  return context;
};

export default VehicleProvider;
```

**IMPORTANT:** When copying addVehicle, updateVehicle, removeVehicle from Store.tsx:
1. Keep all the session verification logic (supabase.auth.getSession(), profile checks)
2. Replace all alert() calls with setLastError(createAppError(...))
3. Keep all console.error() and console.log() calls
4. Keep the loadVehicles() call at the end of each successful operation

Target: ~280 lines (within 300 line limit).
  </action>
  <verify>
- File exists at `triple-j-auto-investment-main/context/VehicleContext.tsx`
- `wc -l triple-j-auto-investment-main/context/VehicleContext.tsx` shows under 300 lines
- `grep "useVehicles" triple-j-auto-investment-main/context/VehicleContext.tsx` shows export
- `npx tsc --noEmit` passes
  </verify>
  <done>VehicleContext.tsx exists with vehicle CRUD operations under 300 lines</done>
</task>

<task type="auto">
  <name>Task 2: Reduce Store.tsx to base coordination only</name>
  <files>triple-j-auto-investment-main/context/Store.tsx</files>
  <action>
After vehicle extraction, Store.tsx should only contain:
1. Lead management (loadLeads, addLead)
2. Google Sheets sync (syncWithGoogleSheets, resetToDefault)
3. CSV parsing helper

Remove from Store.tsx:
1. **FALLBACK_ASSETS array** (lines 35-124) - moved to VehicleContext
2. **Vehicle state declarations** (vehicles, isLoading, hasLoaded, connectionError)
3. **loadVehicles function** (lines 242-326)
4. **addVehicle function** (lines 374-453)
5. **updateVehicle function** (lines 456-555)
6. **removeVehicle function** (lines 558-591)
7. **updateRegistration function** (lines 835-856)
8. **Vehicle real-time subscription** (lines 217-223)

Keep in Store.tsx:
1. **Lead state and functions** (leads, loadLeads, addLead)
2. **Sync functions** (syncWithGoogleSheets, resetToDefault, parseCSVLine)
3. **lastSync state**
4. **Lead real-time subscription**

Update StoreContextType:
```typescript
interface StoreContextType {
  leads: Lead[];
  lastSync: Date | null;
  addLead: (l: Lead) => Promise<void>;
  syncWithGoogleSheets: (silent?: boolean) => Promise<string>;
  resetToDefault: () => void;
}
```

Update Provider value to only include lead/sync fields.

**NOTE on syncWithGoogleSheets:** This function syncs vehicles TO Supabase. It will need access to the vehicle state to work. Options:
1. Move syncWithGoogleSheets to VehicleContext (preferred - it's really about vehicles)
2. Keep in Store and have it call supabase directly (less clean)

**Recommended:** Move syncWithGoogleSheets and resetToDefault to VehicleContext since they're vehicle-related. This makes Store.tsx purely about leads.

After this, Store.tsx should be ~200 lines or less.
  </action>
  <verify>
- `grep "addVehicle" triple-j-auto-investment-main/context/Store.tsx` returns no results
- `grep "loadVehicles" triple-j-auto-investment-main/context/Store.tsx` returns no results
- `wc -l triple-j-auto-investment-main/context/Store.tsx` shows under 300 lines
- `npx tsc --noEmit` passes
  </verify>
  <done>Store.tsx reduced to leads and base state under 300 lines</done>
</task>

<task type="auto">
  <name>Task 3: Wire VehicleProvider into App.tsx and update consumers</name>
  <files>triple-j-auto-investment-main/App.tsx</files>
  <action>
Update App.tsx to include VehicleProvider:

1. **Add import**:
```typescript
import { VehicleProvider } from './context/VehicleContext';
```

2. **Update provider hierarchy**:
```tsx
<ErrorProvider showAdminDetails={true}>
  <AuthProvider>
    <VehicleProvider>
      <StoreProvider>
        <BrowserRouter>
          {/* routes */}
        </BrowserRouter>
      </StoreProvider>
    </VehicleProvider>
  </AuthProvider>
</ErrorProvider>
```

VehicleProvider goes inside AuthProvider (needs useAuth) but outside StoreProvider.

3. **Update consumer files** to use useVehicles instead of useStore for vehicle operations.

Files to update:
- `pages/Inventory.tsx`: Change `const { vehicles, isLoading, hasLoaded, ... } = useStore()` to use useVehicles
- `pages/admin/Inventory.tsx`: Same pattern
- Any other file using vehicle-related fields from useStore

Pattern:
```typescript
// Before:
import { useStore } from '../context/Store';
const { vehicles, isLoading, hasLoaded, addVehicle, updateVehicle } = useStore();

// After:
import { useVehicles } from '../context/VehicleContext';
const { vehicles, isLoading, hasLoaded, addVehicle, updateVehicle } = useVehicles();
```

Keep useStore for leads and sync:
```typescript
import { useStore } from '../context/Store';
const { leads, addLead, lastSync } = useStore();
```
  </action>
  <verify>
- `grep "VehicleProvider" triple-j-auto-investment-main/App.tsx` shows import and usage
- `grep "useVehicles" triple-j-auto-investment-main/pages/Inventory.tsx` shows usage
- `npx tsc --noEmit` passes
  </verify>
  <done>VehicleProvider integrated, consumers updated to use useVehicles</done>
</task>

</tasks>

<verification>
1. VehicleContext.tsx exists and exports useVehicles
2. VehicleContext.tsx is under 300 lines
3. Store.tsx is under 300 lines
4. AuthContext.tsx is under 300 lines (from Plan 04)
5. All three contexts total < 900 lines (same as original Store.tsx but organized)
6. `npx tsc --noEmit` passes
7. No runtime errors when loading inventory page

Line count targets:
- AuthContext.tsx: ~120 lines
- VehicleContext.tsx: ~280 lines
- Store.tsx: ~200 lines
- Total: ~600 lines (vs 888 original) with better organization
</verification>

<success_criteria>
- VehicleContext.tsx exists with vehicle CRUD operations
- All three contexts (Auth, Vehicle, Store) are under 300 lines each
- Inventory page loads and displays vehicles
- Vehicle CRUD operations work (add, update, delete)
- STAB-03 requirement satisfied: Store.tsx decomposed
</success_criteria>

<output>
After completion, create `.planning/phases/01-reliability-stability/01-05-SUMMARY.md`
</output>
