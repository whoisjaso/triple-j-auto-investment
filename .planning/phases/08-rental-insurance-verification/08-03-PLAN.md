---
phase: 08-rental-insurance-verification
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - triple-j-auto-investment-main/supabase/functions/check-plate-alerts/index.ts
  - triple-j-auto-investment-main/supabase/functions/_shared/email-templates/plate-alert.tsx
autonomous: true

must_haves:
  truths:
    - "Edge Function detects insurance expiring within 7 days during active/reserved rentals (warning severity)"
    - "Edge Function detects already-expired insurance on active rentals (urgent severity)"
    - "Edge Function detects active/reserved bookings with no insurance record (missing_insurance alert)"
    - "Detected insurance issues are upserted into insurance_alerts table with deduplication"
    - "Cleared conditions auto-resolve existing active alerts"
    - "Insurance alerts are included in the batched admin notification (same SMS + email as plate alerts)"
  artifacts:
    - path: "triple-j-auto-investment-main/supabase/functions/check-plate-alerts/index.ts"
      provides: "Extended alert detection covering plate alerts + insurance alerts"
      contains: "insurance_alerts"
    - path: "triple-j-auto-investment-main/supabase/functions/_shared/email-templates/plate-alert.tsx"
      provides: "Extended email/SMS templates including insurance alert sections"
      contains: "insurance"
  key_links:
    - from: "check-plate-alerts/index.ts"
      to: "insurance_alerts table"
      via: "supabase upsert"
      pattern: "from\\('insurance_alerts'\\)"
    - from: "check-plate-alerts/index.ts"
      to: "_shared/email-templates/plate-alert.tsx"
      via: "template function calls"
      pattern: "buildInsuranceAlertSection|insurance"
---

<objective>
Extend the existing check-plate-alerts Edge Function to also detect insurance expiration issues, and extend the alert email/SMS templates to include insurance alerts in the batched admin notification.

Purpose: Implements RINS-04 (expiration alerts). When the cron job runs (every 30 minutes), it now checks both plate issues AND insurance issues, sending a single combined notification to the admin.

Output: Extended check-plate-alerts/index.ts, extended plate-alert.tsx templates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-rental-insurance-verification/08-CONTEXT.md
@.planning/phases/08-rental-insurance-verification/08-RESEARCH.md
@.planning/phases/08-rental-insurance-verification/08-01-SUMMARY.md

# Source files to modify
@triple-j-auto-investment-main/supabase/functions/check-plate-alerts/index.ts
@triple-j-auto-investment-main/supabase/functions/_shared/email-templates/plate-alert.tsx

# Migration reference (for table structure)
@supabase/migrations/08_rental_insurance.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend check-plate-alerts Edge Function with Insurance Expiry Detection</name>
  <files>triple-j-auto-investment-main/supabase/functions/check-plate-alerts/index.ts</files>
  <action>
Read the existing check-plate-alerts/index.ts (490 lines) fully before modifying. The function currently:
1. Detects overdue rentals, expiring buyer's tags, and unaccounted plates
2. Upserts alerts into plate_alerts table
3. Auto-resolves cleared plate conditions
4. Sends batched notification (1 SMS + 1 email) via shared helpers

Add a NEW SECTION after the existing plate detection logic but BEFORE the notification sending. Keep the existing plate detection code COMPLETELY untouched. The insurance section should be clearly commented.

**Insurance alert detection (add after plate detection, before notification):**

```typescript
// ================================================================
// INSURANCE ALERT DETECTION (Phase 08)
// ================================================================

// Fetch active/reserved bookings with their insurance records
const { data: bookingsWithInsurance } = await supabase
  .from('rental_bookings')
  .select(`
    id, booking_id, status, start_date, end_date,
    rental_customers ( full_name, phone ),
    rental_insurance ( id, expiration_date, verification_status, insurance_company, policy_number )
  `)
  .in('status', ['active', 'reserved']);

const today = new Date();
today.setHours(0, 0, 0, 0);
const sevenDaysFromNow = new Date(today);
sevenDaysFromNow.setDate(sevenDaysFromNow.getDate() + 7);

const detectedInsuranceAlerts: Array<{
  booking_id: string;
  alert_type: string;
  severity: string;
  notes: string;
}> = [];

for (const booking of (bookingsWithInsurance || [])) {
  const insurance = Array.isArray(booking.rental_insurance)
    ? booking.rental_insurance[0]  // 1:1 but Supabase returns array for nested select
    : booking.rental_insurance;

  if (!insurance) {
    // No insurance record at all for an active/reserved booking
    detectedInsuranceAlerts.push({
      booking_id: booking.id,
      alert_type: 'missing_insurance',
      severity: 'warning',
      notes: `Booking ${booking.booking_id} has no insurance on file`,
    });
    continue;
  }

  if (insurance.verification_status === 'failed') {
    // Failed insurance -- admin already rejected it
    continue; // Don't alert for already-rejected insurance
  }

  if (insurance.expiration_date) {
    const expiryDate = new Date(insurance.expiration_date);
    expiryDate.setHours(0, 0, 0, 0);

    if (expiryDate < today) {
      // Already expired during active rental
      detectedInsuranceAlerts.push({
        booking_id: booking.id,
        alert_type: 'expired',
        severity: 'urgent',
        notes: `Insurance for booking ${booking.booking_id} expired on ${insurance.expiration_date}`,
      });
    } else if (expiryDate <= sevenDaysFromNow) {
      // Expiring within 7 days
      const daysUntilExpiry = Math.ceil((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
      detectedInsuranceAlerts.push({
        booking_id: booking.id,
        alert_type: 'expiring_soon',
        severity: daysUntilExpiry <= 3 ? 'urgent' : 'warning',
        notes: `Insurance for booking ${booking.booking_id} expires in ${daysUntilExpiry} day(s)`,
      });
    }
  }
}

// Upsert detected insurance alerts (deduplication: same booking_id + alert_type)
const newInsuranceAlertIds = new Set<string>();

for (const alert of detectedInsuranceAlerts) {
  const { data: upserted } = await supabase
    .from('insurance_alerts')
    .upsert(
      {
        booking_id: alert.booking_id,
        alert_type: alert.alert_type,
        severity: alert.severity,
        notes: alert.notes,
        first_detected_at: new Date().toISOString(),
      },
      {
        onConflict: 'booking_id,alert_type',
        ignoreDuplicates: true,
      }
    )
    .select('id');

  if (upserted?.[0]?.id) {
    newInsuranceAlertIds.add(upserted[0].id);
  }
}
```

NOTE: The upsert deduplication requires a partial unique index on insurance_alerts(booking_id, alert_type) WHERE resolved_at IS NULL. Add this to the migration in Task 1 of Plan 01 -- actually, since Plan 01 may already be executed, check if the index exists. If it was not included in 08_rental_insurance.sql, add a NOTE in the code comment that the migration needs updating. The executor for Plan 01 should include this index. If Plan 01 is already done, add the CREATE UNIQUE INDEX statement at the top of the detection section as a migration-needs-update comment.

**Actually, the simpler approach (per existing plate_alerts pattern):** Use the exact same upsert-with-ignoreDuplicates pattern from the existing plate detection code. Look at how the existing code handles plate_alerts upserts and mirror that exactly for insurance_alerts. The plate_alerts table uses upsert with ignoreDuplicates -- replicate that pattern.

**Auto-resolve cleared insurance conditions:**
After detection, fetch all active (unresolved) insurance_alerts. For each, check if the condition still exists in detectedInsuranceAlerts. If not, resolve it:

```typescript
// Auto-resolve cleared insurance conditions
const { data: activeInsuranceAlerts } = await supabase
  .from('insurance_alerts')
  .select('id, booking_id, alert_type')
  .is('resolved_at', null);

const detectedInsuranceSet = new Set(
  detectedInsuranceAlerts.map(a => `${a.booking_id}:${a.alert_type}`)
);

for (const active of (activeInsuranceAlerts || [])) {
  if (!detectedInsuranceSet.has(`${active.booking_id}:${active.alert_type}`)) {
    await supabase
      .from('insurance_alerts')
      .update({ resolved_at: new Date().toISOString() })
      .eq('id', active.id);
  }
}
```

**Integrate into notification:**
Collect insurance alerts alongside plate alerts for the batched notification. The existing code builds arrays of alert data for the email/SMS templates. Add insurance alerts to those arrays:

```typescript
// Combine plate alerts + insurance alerts for notification
const insuranceAlertsForNotification = detectedInsuranceAlerts.map(a => ({
  type: a.alert_type,
  severity: a.severity,
  description: a.notes,
  bookingId: (bookingsWithInsurance || []).find(b => b.id === a.booking_id)?.booking_id || 'Unknown',
}));
```

Pass this array to the email/SMS template functions (updated in Task 2). Only send notification if there are alerts (plate OR insurance) -- don't send empty notifications.

Apply the existing 24-hour notification cooldown check. Look at how the existing code tracks last_notified_at on plate_alerts and replicate for insurance_alerts.
  </action>
  <verify>
1. Existing plate detection code is completely unchanged (diff shows only additions)
2. Insurance detection queries rental_bookings with rental_insurance join
3. Three alert types detected: missing_insurance, expired, expiring_soon
4. Severity escalation: expiring_soon with <= 3 days = urgent, > 3 days = warning
5. Upsert deduplication prevents duplicate alerts
6. Auto-resolve clears conditions that no longer exist
7. Insurance alerts included in notification payload alongside plate alerts
  </verify>
  <done>
check-plate-alerts Edge Function extended with insurance expiry detection section. Detects 3 alert types (missing, expired, expiring_soon) with severity escalation. Deduplication via upsert, auto-resolve for cleared conditions, and insurance alerts included in batched admin notification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Email/SMS Templates for Insurance Alerts</name>
  <files>triple-j-auto-investment-main/supabase/functions/_shared/email-templates/plate-alert.tsx</files>
  <action>
Read the existing plate-alert.tsx (297 lines) fully before modifying. It currently:
1. Exports a function to build the HTML email template for plate alerts
2. Exports a function to build the SMS text for plate alerts
3. Uses the template literal HTML pattern (NOT React JSX)

**Extend the email template function:**

Add a new section to the existing email HTML for insurance alerts. The email should now have two sections if both types of alerts exist:
- "Plate Alerts" section (existing, unchanged)
- "Insurance Alerts" section (new)

If only plate alerts exist, show only the plate section (backward compatible).
If only insurance alerts exist, show only the insurance section.
If both exist, show both sections with a divider.

Insurance alert section HTML (matching existing luxury dark theme):
- Section header: "Insurance Alerts" with a shield icon (inline SVG or emoji shield).
- For each insurance alert: a row with severity badge (warning=amber, urgent=red), alert description, and booking ID.
- Color coding matches existing: urgent = red (#ef4444), warning = amber (#f59e0b).

Update the function signature to accept an optional `insuranceAlerts` parameter:
```typescript
export function buildAlertEmailHtml(
  plateAlerts: PlateAlertData[],
  insuranceAlerts?: InsuranceAlertData[],
): string
```

Where InsuranceAlertData is:
```typescript
interface InsuranceAlertData {
  type: string;       // 'expiring_soon' | 'expired' | 'coverage_below_minimum' | 'missing_insurance'
  severity: string;   // 'warning' | 'urgent'
  description: string;
  bookingId: string;
}
```

**Extend the SMS template function:**

Update the SMS builder to include insurance alerts in the summary text. The existing pattern sends a concise SMS like "Triple J Alert: 2 plates overdue, 1 tag expiring". Extend to: "Triple J Alert: 2 plates overdue, 1 tag expiring, 1 insurance expired, 1 insurance expiring".

Update the SMS function signature similarly:
```typescript
export function buildAlertSmsText(
  plateAlerts: PlateAlertData[],
  insuranceAlerts?: InsuranceAlertData[],
): string
```

**Update the email subject line:**
If insurance alerts are included, update the subject to mention insurance. E.g., "Triple J: 3 Plate Alerts, 2 Insurance Alerts" instead of just "Triple J: 3 Plate Alerts".

**Export the InsuranceAlertData interface** so the Edge Function can import it.

**Critical: Keep the existing plate alert rendering COMPLETELY untouched.** The insurance sections are additive. If insuranceAlerts is undefined or empty, the output should be identical to the current output (backward compatible).

**Also update the corresponding call sites in check-plate-alerts/index.ts** (from Task 1) to pass the insurance alerts array to these template functions.
  </action>
  <verify>
1. Existing plate alert email HTML is unchanged when no insurance alerts are passed
2. Email template includes insurance section with severity-colored badges when insurance alerts present
3. SMS template includes insurance alert counts in summary text
4. InsuranceAlertData interface is exported
5. Email subject line reflects both plate and insurance alert counts
6. Both template functions accept optional insuranceAlerts parameter (backward compatible)
  </verify>
  <done>
plate-alert.tsx extended with InsuranceAlertData interface, insurance alert section in email template (severity badges, booking IDs), and insurance counts in SMS summary. Fully backward compatible -- no change in output when no insurance alerts are present. Edge Function passes insurance alerts to template functions.
  </done>
</task>

</tasks>

<verification>
1. Existing plate alert functionality is completely unchanged (regression check)
2. Insurance detection runs as part of the same cron cycle
3. Three insurance alert types detected: missing_insurance, expired, expiring_soon
4. Alerts stored in insurance_alerts table (not plate_alerts)
5. Email template renders insurance section alongside plate section
6. SMS includes insurance alert counts
7. Auto-resolve works for cleared insurance conditions
8. 24-hour notification cooldown applies to insurance alerts
</verification>

<success_criteria>
- RINS-04: Expiration alerts fire when insurance expires during rental period
- Alert detection runs on the same 30-minute cron as plate alerts
- Batched notification: admin gets ONE combined email/SMS covering both plate and insurance issues
- Backward compatible: existing plate alert behavior unchanged
- Insurance alert lifecycle: detect -> upsert -> notify -> auto-resolve when cleared
</success_criteria>

<output>
After completion, create `.planning/phases/08-rental-insurance-verification/08-03-SUMMARY.md`
</output>
