---
phase: 08-rental-insurance-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/08_rental_insurance.sql
  - triple-j-auto-investment-main/types.ts
  - triple-j-auto-investment-main/services/insuranceService.ts
autonomous: true

must_haves:
  truths:
    - "rental_insurance table exists with booking_id FK, policy fields, coverage amounts, verification status, and card_image_url"
    - "insurance_alerts table exists parallel to plate_alerts with booking_id FK, alert_type CHECK, severity, and resolution tracking"
    - "RLS policies allow admin CRUD on both tables"
    - "TypeScript interfaces match all DB columns with camelCase naming"
    - "insuranceService.ts provides CRUD, validation, upload, and transformer functions"
  artifacts:
    - path: "supabase/migrations/08_rental_insurance.sql"
      provides: "rental_insurance and insurance_alerts tables, RLS, triggers, customer pre-fill columns"
      contains: "CREATE TABLE IF NOT EXISTS public.rental_insurance"
    - path: "triple-j-auto-investment-main/types.ts"
      provides: "RentalInsurance, InsuranceVerificationFlags, InsuranceAlert interfaces, TEXAS_MINIMUM_COVERAGE constant"
      contains: "RENTAL INSURANCE TYPES"
    - path: "triple-j-auto-investment-main/services/insuranceService.ts"
      provides: "Insurance CRUD, validateInsuranceCoverage, uploadInsuranceCard, transformInsurance"
      exports: ["getInsuranceForBooking", "createInsurance", "updateInsurance", "verifyInsurance", "overrideInsurance", "uploadInsuranceCard", "validateInsuranceCoverage"]
  key_links:
    - from: "services/insuranceService.ts"
      to: "supabase rental_insurance table"
      via: "supabase client queries"
      pattern: "supabase\\.from\\('rental_insurance'\\)"
    - from: "types.ts"
      to: "services/insuranceService.ts"
      via: "type imports"
      pattern: "import.*RentalInsurance.*from.*types"
---

<objective>
Create the database schema, TypeScript types, and service layer for rental insurance verification.

Purpose: Establishes the data foundation that the UI (Plan 02) and alert system (Plan 03) will build on. Every rental booking will have an associated insurance record that tracks policy details, coverage amounts, verification status, and insurance card images.

Output: Migration SQL file, extended types.ts, new insuranceService.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-rental-insurance-verification/08-CONTEXT.md
@.planning/phases/08-rental-insurance-verification/08-RESEARCH.md

# Key source files
@triple-j-auto-investment-main/types.ts
@triple-j-auto-investment-main/services/rentalService.ts
@triple-j-auto-investment-main/services/plateService.ts
@triple-j-auto-investment-main/supabase/config.ts

# Migration patterns
@supabase/migrations/07_plate_tracking.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database Migration (08_rental_insurance.sql)</name>
  <files>supabase/migrations/08_rental_insurance.sql</files>
  <action>
Create the migration file following the established pattern from 06_rental_schema.sql and 07_plate_tracking.sql. The migration must be idempotent (IF NOT EXISTS, DO blocks with information_schema guards).

**Section 1: rental_insurance table**
```sql
CREATE TABLE IF NOT EXISTS public.rental_insurance (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  booking_id UUID NOT NULL REFERENCES public.rental_bookings(id) ON DELETE CASCADE,

  -- Insurance source type
  insurance_type TEXT NOT NULL DEFAULT 'customer_provided'
    CHECK (insurance_type IN ('customer_provided', 'dealer_coverage')),

  -- Policy details (customer_provided)
  insurance_company TEXT,
  policy_number TEXT,
  effective_date DATE,
  expiration_date DATE,

  -- Coverage amounts (whole dollars, INTEGER -- not DECIMAL)
  bodily_injury_per_person INTEGER,    -- Texas min: 30000
  bodily_injury_per_accident INTEGER,  -- Texas min: 60000
  property_damage INTEGER,             -- Texas min: 25000

  -- Insurance card image
  card_image_url TEXT,

  -- Verification status
  verification_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (verification_status IN ('pending', 'verified', 'failed', 'overridden')),
  verified_by TEXT,
  verified_at TIMESTAMPTZ,
  verification_notes TEXT,

  -- System-computed flags
  coverage_meets_minimum BOOLEAN DEFAULT false,
  expires_during_rental BOOLEAN DEFAULT false,

  -- Dealer coverage specifics (when insurance_type = 'dealer_coverage')
  dealer_coverage_daily_rate DECIMAL(10,2),
  dealer_coverage_total DECIMAL(10,2),

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

Add a UNIQUE constraint on booking_id (1:1 relationship with rental_bookings) using the DO block + information_schema guard pattern from Phase 7.

**Section 2: insurance_alerts table** (parallel to plate_alerts, separate table per RESEARCH.md Pitfall 6)
```sql
CREATE TABLE IF NOT EXISTS public.insurance_alerts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  booking_id UUID NOT NULL REFERENCES public.rental_bookings(id) ON DELETE CASCADE,
  alert_type TEXT NOT NULL CHECK (alert_type IN ('expiring_soon', 'expired', 'coverage_below_minimum', 'missing_insurance')),
  severity TEXT NOT NULL CHECK (severity IN ('warning', 'urgent')),
  first_detected_at TIMESTAMPTZ DEFAULT NOW(),
  last_notified_at TIMESTAMPTZ,
  resolved_at TIMESTAMPTZ,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Section 3: Customer pre-fill columns on rental_customers**
Add columns using ALTER TABLE ... ADD COLUMN IF NOT EXISTS:
- last_insurance_company TEXT
- last_policy_number TEXT
- last_insurance_expiry DATE

These allow pre-filling insurance from the customer's most recent booking.

**Section 4: updated_at trigger**
Create a trigger function `update_insurance_updated_at()` (dedicated, not reusing generic) and attach it to rental_insurance BEFORE UPDATE.

**Section 5: RLS policies**
- Enable RLS on both tables.
- rental_insurance: admin can SELECT, INSERT, UPDATE, DELETE. No public access.
- insurance_alerts: admin can SELECT, INSERT, UPDATE. No DELETE (immutable alert log, resolve instead).

**Section 6: Indexes**
- Index on rental_insurance(booking_id) for FK lookups (already unique, but explicit).
- Index on insurance_alerts(booking_id, resolved_at) for active alert queries.
- Partial index on insurance_alerts WHERE resolved_at IS NULL for fast active-alert lookups.

Do NOT use TIMESTAMPTZ for date-only fields (effective_date, expiration_date). Use DATE type to avoid timezone off-by-one per RESEARCH.md Pitfall 1.

Do NOT use DECIMAL for coverage amounts. Use INTEGER (whole dollar values) per RESEARCH.md Anti-Patterns.
  </action>
  <verify>
Review the SQL file for:
1. All CREATE TABLE IF NOT EXISTS statements parse correctly
2. CHECK constraints on insurance_type, verification_status, alert_type, severity
3. UNIQUE constraint on rental_insurance(booking_id)
4. RLS policies enabled and created
5. Indexes created
6. Trigger function and trigger attached
7. No TIMESTAMPTZ on date-only fields (effective_date, expiration_date use DATE)
8. Coverage amounts use INTEGER not DECIMAL
  </verify>
  <done>
Migration file exists at supabase/migrations/08_rental_insurance.sql with rental_insurance table, insurance_alerts table, customer pre-fill columns, RLS policies, trigger, and indexes. File is idempotent (safe to re-run).
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript Types and insuranceService.ts</name>
  <files>
    triple-j-auto-investment-main/types.ts
    triple-j-auto-investment-main/services/insuranceService.ts
  </files>
  <action>
**types.ts additions:**

Add a new section after the PLATE TRACKING TYPES section:

```typescript
// ================================================================
// RENTAL INSURANCE TYPES (Phase 08)
// ================================================================

export type InsuranceType = 'customer_provided' | 'dealer_coverage';

export type InsuranceVerificationStatus = 'pending' | 'verified' | 'failed' | 'overridden';

export type InsuranceAlertType = 'expiring_soon' | 'expired' | 'coverage_below_minimum' | 'missing_insurance';

export type InsuranceAlertSeverity = 'warning' | 'urgent';

export interface RentalInsurance {
  id: string;
  bookingId: string;
  insuranceType: InsuranceType;
  insuranceCompany?: string;
  policyNumber?: string;
  effectiveDate?: string;
  expirationDate?: string;
  bodilyInjuryPerPerson?: number;
  bodilyInjuryPerAccident?: number;
  propertyDamage?: number;
  cardImageUrl?: string;
  verificationStatus: InsuranceVerificationStatus;
  verifiedBy?: string;
  verifiedAt?: string;
  verificationNotes?: string;
  coverageMeetsMinimum: boolean;
  expiresDuringRental: boolean;
  dealerCoverageDailyRate?: number;
  dealerCoverageTotal?: number;
  createdAt: string;
  updatedAt: string;
}

export interface InsuranceVerificationFlags {
  hasRequiredFields: boolean;
  coverageMeetsMinimum: boolean;
  policyNotExpired: boolean;
  noExpiryDuringRental: boolean;
  cardImageUploaded: boolean;
}

export interface InsuranceAlert {
  id: string;
  bookingId: string;
  alertType: InsuranceAlertType;
  severity: InsuranceAlertSeverity;
  firstDetectedAt: string;
  lastNotifiedAt?: string;
  resolvedAt?: string;
  notes?: string;
  createdAt: string;
}

export const TEXAS_MINIMUM_COVERAGE = {
  bodilyInjuryPerPerson: 30000,
  bodilyInjuryPerAccident: 60000,
  propertyDamage: 25000,
} as const;

export const TEXAS_MINIMUM_LABEL = '30/60/25';

export const INSURANCE_STATUS_LABELS: Record<InsuranceVerificationStatus, string> = {
  pending: 'Pending',
  verified: 'Verified',
  failed: 'Failed',
  overridden: 'Overridden',
};
```

Also add an optional `insurance` field to the `RentalBooking` interface:
```typescript
  insurance?: RentalInsurance;
```

**insuranceService.ts:**

Create a new service file following the exact pattern of plateService.ts and rentalService.ts. Import from supabase config and types.

Functions to implement:

1. `transformInsurance(data: any): RentalInsurance` -- snake_case to camelCase transformer. Use parseFloat for dealer_coverage_daily_rate and dealer_coverage_total (DECIMAL columns per Pitfall 2). Use parseInt or direct assignment for INTEGER coverage amounts.

2. `transformInsuranceAlert(data: any): InsuranceAlert` -- transformer for insurance_alerts rows.

3. `getInsuranceForBooking(bookingId: string): Promise<RentalInsurance | null>` -- SELECT from rental_insurance WHERE booking_id = bookingId, returns null if not found.

4. `createInsurance(data: { bookingId, insuranceType, insuranceCompany?, policyNumber?, effectiveDate?, expirationDate?, bodilyInjuryPerPerson?, bodilyInjuryPerAccident?, propertyDamage?, dealerCoverageDailyRate?, dealerCoverageTotal? }): Promise<RentalInsurance | null>` -- INSERT into rental_insurance. Before inserting, compute coverage_meets_minimum and expires_during_rental flags using validateInsuranceCoverage. Must map camelCase params to snake_case DB columns.

5. `updateInsurance(id: string, data: Partial<...>): Promise<RentalInsurance | null>` -- UPDATE rental_insurance. Recompute system flags if coverage amounts or dates change.

6. `verifyInsurance(id: string, verifiedBy: string, notes?: string): Promise<boolean>` -- Set verification_status='verified', verified_by, verified_at=NOW(), verification_notes.

7. `failInsurance(id: string, verifiedBy: string, notes: string): Promise<boolean>` -- Set verification_status='failed'.

8. `overrideInsurance(id: string, overriddenBy: string, notes: string): Promise<boolean>` -- Set verification_status='overridden'. Log same as RegistrationChecker override pattern.

9. `uploadInsuranceCard(bookingId: string, file: File): Promise<string | null>` -- Upload to 'insurance-cards' bucket following plateService.uploadPlatePhoto pattern exactly. Path: `insurance/${bookingId}/${Date.now()}.${ext}`. On success, update the rental_insurance row's card_image_url.

10. `validateInsuranceCoverage(insurance: Partial<RentalInsurance>, bookingEndDate?: string): InsuranceVerificationFlags` -- PURE function (no DB calls). Compare coverage amounts against TEXAS_MINIMUM_COVERAGE. Check dates using zeroed-time comparison (per RESEARCH.md Pitfall 1, same as calculateTagExpiry). Return flags object.

11. `getActiveInsuranceAlerts(): Promise<InsuranceAlert[]>` -- SELECT from insurance_alerts WHERE resolved_at IS NULL.

12. `updateCustomerInsuranceCache(customerId: string, insurance: Partial<RentalInsurance>): Promise<void>` -- UPDATE rental_customers SET last_insurance_company, last_policy_number, last_insurance_expiry. For pre-fill on next booking.

13. `getCustomerLastInsurance(customerId: string): Promise<{ company?: string; policyNumber?: string; expiry?: string } | null>` -- SELECT last_insurance_company, last_policy_number, last_insurance_expiry FROM rental_customers WHERE id = customerId.

All functions use the established error handling pattern: try/catch, console.error, return null/false on failure.

Do NOT use `any` for function parameters when a proper type exists. Use Partial<RentalInsurance> or explicit param types.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (or at minimum, no NEW errors introduced -- pre-existing errors acceptable per STATE.md)
2. types.ts contains RentalInsurance, InsuranceVerificationFlags, InsuranceAlert interfaces
3. types.ts contains TEXAS_MINIMUM_COVERAGE constant with 30000/60000/25000
4. RentalBooking interface has optional insurance field
5. insuranceService.ts exports all 13 functions listed above
6. insuranceService.ts uses parseFloat for DECIMAL columns, direct assignment for INTEGER
7. validateInsuranceCoverage is a pure function with no supabase imports in its body
  </verify>
  <done>
types.ts extended with insurance types section (InsuranceType, InsuranceVerificationStatus, RentalInsurance, InsuranceVerificationFlags, InsuranceAlert, TEXAS_MINIMUM_COVERAGE). insuranceService.ts created with CRUD operations, validation, upload, and customer cache functions. All transformers handle snake_case to camelCase mapping correctly.
  </done>
</task>

</tasks>

<verification>
1. Migration SQL is syntactically valid and idempotent
2. TypeScript compiles without new errors
3. insuranceService.ts follows same patterns as plateService.ts (transformer, CRUD, upload)
4. TEXAS_MINIMUM_COVERAGE matches official Texas 30/60/25 requirement
5. No DECIMAL used for coverage amounts (INTEGER only)
6. DATE type used for date-only fields, not TIMESTAMPTZ
</verification>

<success_criteria>
- rental_insurance and insurance_alerts tables defined in migration SQL
- RentalInsurance interface maps 1:1 with DB columns
- insuranceService.ts provides complete CRUD + validation + upload
- validateInsuranceCoverage pure function works without DB access
- Customer pre-fill columns added to rental_customers
- All code follows established project patterns
</success_criteria>

<output>
After completion, create `.planning/phases/08-rental-insurance-verification/08-01-SUMMARY.md`
</output>
