---
phase: 07-plate-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - triple-j-auto-investment-main/supabase/migrations/07_plate_tracking.sql
  - triple-j-auto-investment-main/types.ts
  - triple-j-auto-investment-main/services/plateService.ts
autonomous: true

must_haves:
  truths:
    - "Plates table exists with plate_number, plate_type, status, expiration_date, photo_url, notes columns"
    - "Plate assignments table exists with immutable history log pattern"
    - "Plate status auto-updates to 'assigned' on new assignment and 'available' on return via DB trigger"
    - "Partial unique index prevents two active assignments for the same plate"
    - "TypeScript Plate and PlateAssignment interfaces match DB schema with camelCase mapping"
    - "plateService.ts provides full CRUD, assignment, return, swap, and query functions"
  artifacts:
    - path: "triple-j-auto-investment-main/supabase/migrations/07_plate_tracking.sql"
      provides: "plates, plate_assignments, plate_alerts tables with triggers, indexes, RLS"
      contains: "CREATE TABLE IF NOT EXISTS public.plates"
    - path: "triple-j-auto-investment-main/types.ts"
      provides: "PlateType, PlateStatus, Plate, PlateAssignment, PlateAlert types"
      contains: "export type PlateType"
    - path: "triple-j-auto-investment-main/services/plateService.ts"
      provides: "All plate CRUD, assignment, and query operations"
      exports: ["getAllPlates", "getPlatesOut", "assignPlateToBooking", "returnPlateAssignment", "getAvailableDealerPlates", "getPlateHistory"]
  key_links:
    - from: "services/plateService.ts"
      to: "supabase/config.ts"
      via: "supabase client import"
      pattern: "import.*supabase.*from.*config"
    - from: "services/plateService.ts"
      to: "types.ts"
      via: "type imports"
      pattern: "import.*Plate.*from.*types"
---

<objective>
Create the plate tracking database schema, TypeScript type definitions, and complete service layer.

Purpose: This is the foundation for all plate tracking features. Every other plan in this phase depends on these tables, types, and service functions existing. Plates become first-class entities with their own lifecycle independent of vehicles and bookings.

Output: Migration SQL file (plates + plate_assignments + plate_alerts tables with triggers, indexes, RLS), TypeScript types added to types.ts, and a complete plateService.ts following the established transformer pattern.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-plate-tracking/07-CONTEXT.md
@.planning/phases/07-plate-tracking/07-RESEARCH.md

Key reference files for patterns:
@triple-j-auto-investment-main/supabase/migrations/06_rental_schema.sql
@triple-j-auto-investment-main/services/rentalService.ts
@triple-j-auto-investment-main/types.ts
@triple-j-auto-investment-main/supabase/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database Migration - Plates, Assignments, and Alerts Tables</name>
  <files>triple-j-auto-investment-main/supabase/migrations/07_plate_tracking.sql</files>
  <action>
Create `07_plate_tracking.sql` following the exact patterns from `06_rental_schema.sql` (idempotent IF NOT EXISTS, DO blocks for constraints, SECURITY DEFINER triggers).

**1. plates table:**
- `id` UUID PK with uuid_generate_v4()
- `plate_number` VARCHAR(20) NOT NULL with UNIQUE constraint
- `plate_type` TEXT NOT NULL with CHECK IN ('dealer', 'buyer_tag', 'permanent')
- `status` TEXT NOT NULL DEFAULT 'available' with CHECK IN ('available', 'assigned', 'expired', 'lost')
- `expiration_date` DATE (required for buyer_tag, optional for dealer, N/A for permanent)
- `photo_url` TEXT (Supabase Storage URL for plate photo)
- `notes` TEXT
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()

**2. plate_assignments table (immutable history log):**
- `id` UUID PK
- `plate_id` UUID NOT NULL REFERENCES plates(id)
- `vehicle_id` UUID REFERENCES vehicles(id)
- `booking_id` UUID REFERENCES rental_bookings(id)
- `registration_id` UUID REFERENCES registrations(id)
- `customer_name` TEXT (denormalized for fast dashboard queries)
- `customer_phone` TEXT (denormalized)
- `assignment_type` TEXT NOT NULL CHECK IN ('rental', 'sale', 'inventory')
- `assigned_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()
- `expected_return_date` DATE
- `returned_at` TIMESTAMPTZ (NULL = still out)
- `return_confirmed` BOOLEAN DEFAULT false
- `notes` TEXT
- `created_at` TIMESTAMPTZ DEFAULT NOW()

**3. plate_alerts table (deduplication for notifications):**
- `id` UUID PK
- `plate_id` UUID NOT NULL REFERENCES plates(id)
- `alert_type` TEXT NOT NULL CHECK IN ('overdue_rental', 'expiring_buyer_tag', 'unaccounted')
- `severity` TEXT NOT NULL DEFAULT 'warning' CHECK IN ('warning', 'urgent')
- `first_detected_at` TIMESTAMPTZ NOT NULL DEFAULT NOW()
- `last_notified_at` TIMESTAMPTZ
- `resolved_at` TIMESTAMPTZ
- `notes` TEXT
- `created_at` TIMESTAMPTZ DEFAULT NOW()

**4. Indexes:**
- Partial unique index on plate_assignments: `(plate_id) WHERE (returned_at IS NULL)` -- prevents two active assignments for the same plate
- Partial unique index on plate_alerts: `(plate_id, alert_type) WHERE (resolved_at IS NULL)` -- one active alert per type per plate
- Index on plates(status) for dashboard filtering
- Index on plate_assignments(plate_id) for history lookups
- Index on plate_assignments(booking_id) for rental join queries

**5. Trigger: update_plate_status_on_assignment()**
- AFTER INSERT on plate_assignments: If returned_at IS NULL, set plates.status = 'assigned'
- AFTER UPDATE on plate_assignments: If OLD.returned_at IS NULL AND NEW.returned_at IS NOT NULL, check for other active assignments; if none, set plates.status = 'available'
- Use SECURITY DEFINER (same pattern as Phase 4 notification trigger)

**6. Trigger: update_plates_updated_at()**
- BEFORE UPDATE on plates: Set updated_at = NOW()

**7. RLS Policies (follow Phase 6 pattern):**
- plates: Admin can SELECT, INSERT, UPDATE, DELETE; anonymous SELECT for public plate info (if needed) or admin-only
- plate_assignments: Admin can SELECT, INSERT, UPDATE; no DELETE (immutable log)
- plate_alerts: Admin can SELECT, INSERT, UPDATE; no DELETE

Use the same `auth.jwt() ->> 'email'` pattern for admin checks as in 06_rental_schema.sql. Check the exact RLS pattern used there and replicate it.
  </action>
  <verify>
Review the SQL file for:
1. All three tables created with IF NOT EXISTS
2. Both partial unique indexes created with IF NOT EXISTS
3. Trigger function + trigger attachment for plate status auto-update
4. RLS enabled on all three tables with admin policies
5. No syntax errors (compare structure against 06_rental_schema.sql)
  </verify>
  <done>Migration file exists at supabase/migrations/07_plate_tracking.sql with plates, plate_assignments, and plate_alerts tables, all indexes, triggers, and RLS policies. File is idempotent (re-runnable).</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript Types and Service Layer</name>
  <files>
    triple-j-auto-investment-main/types.ts
    triple-j-auto-investment-main/services/plateService.ts
  </files>
  <action>
**A. Add types to types.ts** (after the Rental Management Types section, add a new section):

```typescript
// ================================================================
// PLATE TRACKING TYPES (Phase 07)
// ================================================================

export type PlateType = 'dealer' | 'buyer_tag' | 'permanent';

export type PlateStatus = 'available' | 'assigned' | 'expired' | 'lost';

export type PlateAssignmentType = 'rental' | 'sale' | 'inventory';

export type PlateAlertType = 'overdue_rental' | 'expiring_buyer_tag' | 'unaccounted';

export type PlateAlertSeverity = 'warning' | 'urgent';

export interface Plate {
  id: string;
  plateNumber: string;
  plateType: PlateType;
  status: PlateStatus;
  expirationDate?: string;
  photoUrl?: string;
  notes?: string;
  createdAt: string;
  updatedAt: string;
  // Derived from active assignment join (optional)
  currentAssignment?: PlateAssignment;
}

export interface PlateAssignment {
  id: string;
  plateId: string;
  vehicleId?: string;
  bookingId?: string;
  registrationId?: string;
  customerName?: string;
  customerPhone?: string;
  assignmentType: PlateAssignmentType;
  assignedAt: string;
  expectedReturnDate?: string;
  returnedAt?: string;
  returnConfirmed: boolean;
  notes?: string;
  createdAt: string;
  // Optional joins
  plate?: Plate;
  vehicle?: Vehicle;
}

export interface PlateAlert {
  id: string;
  plateId: string;
  alertType: PlateAlertType;
  severity: PlateAlertSeverity;
  firstDetectedAt: string;
  lastNotifiedAt?: string;
  resolvedAt?: string;
  notes?: string;
  createdAt: string;
}
```

Also add these pure utility constants/functions at the end of types.ts:
```typescript
export const PLATE_TYPE_LABELS: Record<PlateType, string> = {
  dealer: 'Dealer Plate',
  buyer_tag: "Buyer's Tag",
  permanent: 'Permanent Plate',
};

export const PLATE_STATUS_LABELS: Record<PlateStatus, string> = {
  available: 'Available',
  assigned: 'Assigned',
  expired: 'Expired',
  lost: 'Lost',
};
```

**B. Create services/plateService.ts** following the exact pattern from rentalService.ts:

1. **Transformers:**
   - `transformPlate(data: any): Plate` -- snake_case to camelCase mapping. For currentAssignment, check `data.plate_assignments` array and take the first item where returned_at IS NULL, then call transformAssignment on it.
   - `transformAssignment(data: any): PlateAssignment` -- snake_case to camelCase mapping. Handle optional vehicle join with existing Vehicle transform if present.
   - `transformAlert(data: any): PlateAlert` -- snake_case to camelCase mapping.

2. **Plate CRUD:**
   - `getAllPlates(): Promise<Plate[]>` -- SELECT *, plate_assignments(*) from plates, ORDER BY plate_number. Client-side filter plate_assignments to only active (returned_at IS NULL) for currentAssignment.
   - `getPlateById(id: string): Promise<Plate | null>` -- Single plate with assignments.
   - `createPlate(plate: Partial<Plate>): Promise<Plate | null>` -- INSERT, transform camelCase to snake_case for write.
   - `updatePlate(id: string, updates: Partial<Plate>): Promise<boolean>` -- UPDATE, same mapping.
   - `deletePlate(id: string): Promise<boolean>` -- DELETE (only if no active assignments).

3. **Plates-Out Query:**
   - `getPlatesOut(): Promise<Plate[]>` -- SELECT plates WHERE status = 'assigned', JOIN plate_assignments WHERE returned_at IS NULL. Include vehicle info if available via booking/vehicle join.

4. **Available Plates:**
   - `getAvailableDealerPlates(): Promise<Plate[]>` -- SELECT plates WHERE plate_type = 'dealer' AND status = 'available'.

5. **Assignment Operations:**
   - `assignPlateToBooking(plateId, bookingId, vehicleId, customerName, customerPhone, expectedReturnDate): Promise<PlateAssignment | null>` -- INSERT into plate_assignments with assignment_type = 'rental'.
   - `assignPlateToSale(plateId, registrationId, vehicleId, customerName, customerPhone, expirationDate): Promise<PlateAssignment | null>` -- INSERT with assignment_type = 'sale'. Also update the plate's expiration_date if it's a buyer's tag.
   - `returnPlateAssignment(assignmentId: string, returnConfirmed: boolean): Promise<boolean>` -- UPDATE plate_assignments SET returned_at = NOW(), return_confirmed = returnConfirmed. The DB trigger handles flipping plate status to 'available'.
   - `swapPlateAssignment(plateId: string, newVehicleId: string, newBookingId: string, customerName: string, customerPhone: string, expectedReturnDate: string): Promise<PlateAssignment | null>` -- Close current active assignment (set returned_at), then create new assignment. Two sequential operations per research guidance (not atomic -- safe because partial unique index prevents double-active).

6. **History:**
   - `getPlateHistory(plateId: string): Promise<PlateAssignment[]>` -- SELECT plate_assignments WHERE plate_id ORDER BY assigned_at DESC.

7. **Alerts:**
   - `getActiveAlerts(): Promise<PlateAlert[]>` -- SELECT plate_alerts WHERE resolved_at IS NULL, JOIN plates for plate info.
   - `resolveAlert(alertId: string): Promise<boolean>` -- UPDATE SET resolved_at = NOW().

8. **Pure Utility Function:**
   - `calculateTagExpiry(expirationDate: string): { daysRemaining: number; severity: 'ok' | 'warning' | 'urgent' | 'expired' }` -- Pure function. expired if <= 0, urgent if <= 7, warning if <= 14, ok otherwise. Uses date math without time components.

9. **Photo Upload:**
   - `uploadPlatePhoto(plateId: string, file: File): Promise<string | null>` -- Upload to Supabase Storage bucket 'plate-photos', path `plates/{plateId}/{timestamp}.{ext}`. Return public URL. Follow the pattern from condition report photo uploads in Phase 6 if one exists, otherwise use standard `.from('plate-photos').upload()` + `.getPublicUrl()`.
  </action>
  <verify>
1. `npx tsc --noEmit` from the triple-j-auto-investment-main directory should not introduce new type errors (pre-existing errors are acceptable per STATE.md)
2. Grep types.ts for "PlateType" -- should find the type definition
3. Grep plateService.ts for "transformPlate" -- should find the transformer
4. Grep plateService.ts for "export async function" -- should find at least 12 exported functions
  </verify>
  <done>
types.ts contains PlateType, PlateStatus, PlateAssignmentType, PlateAlertType, Plate, PlateAssignment, PlateAlert interfaces, and PLATE_TYPE_LABELS/PLATE_STATUS_LABELS constants. plateService.ts contains transformPlate, transformAssignment, transformAlert transformers plus all CRUD, assignment, return, swap, history, alert, and photo upload functions following the rentalService.ts pattern.
  </done>
</task>

</tasks>

<verification>
1. Migration SQL is syntactically valid and idempotent (IF NOT EXISTS throughout)
2. TypeScript types in types.ts match the DB schema column-for-column (camelCase mapping)
3. plateService.ts follows the transformer pattern from rentalService.ts
4. No new TypeScript compilation errors introduced
5. Partial unique index pattern matches the one from 04_notification_system.sql
</verification>

<success_criteria>
- 07_plate_tracking.sql exists with 3 tables, 2 partial unique indexes, 2 triggers, and RLS policies
- types.ts has Plate, PlateAssignment, PlateAlert interfaces and related type aliases
- plateService.ts has full CRUD (5+ functions), assignment ops (4 functions), history, alerts, photo upload, and calculateTagExpiry pure function
- TypeScript compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-plate-tracking/07-01-SUMMARY.md`
</output>
