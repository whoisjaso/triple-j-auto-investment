---
phase: 06-rental-management-core
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - triple-j-auto-investment-main/types.ts
  - triple-j-auto-investment-main/services/rentalService.ts
  - triple-j-auto-investment-main/lib/store/types.ts
  - triple-j-auto-investment-main/lib/store/rentals.ts
  - triple-j-auto-investment-main/lib/store/index.ts
  - triple-j-auto-investment-main/context/Store.tsx
autonomous: true

must_haves:
  truths:
    - "TypeScript types exist for all rental entities (booking, customer, payment, condition report)"
    - "Service layer provides full CRUD for bookings, customers, and payments"
    - "Store module exposes rental state and operations via existing facade pattern"
    - "Snake_case to camelCase transformers exist for all rental tables"
  artifacts:
    - path: "triple-j-auto-investment-main/types.ts"
      provides: "RentalBooking, RentalCustomer, RentalPayment, RentalConditionReport interfaces"
      contains: "RentalBooking"
    - path: "triple-j-auto-investment-main/services/rentalService.ts"
      provides: "Full rental CRUD service layer"
      exports: ["getAllBookings", "createBooking", "updateBooking", "getAvailableVehicles", "createPayment"]
    - path: "triple-j-auto-investment-main/lib/store/rentals.ts"
      provides: "Store module for rental state"
      exports: ["loadBookings"]
    - path: "triple-j-auto-investment-main/context/Store.tsx"
      provides: "Rental state integrated into StoreProvider"
      contains: "bookings"
  key_links:
    - from: "triple-j-auto-investment-main/services/rentalService.ts"
      to: "supabase"
      via: "supabase client import"
      pattern: "from.*supabase/config"
    - from: "triple-j-auto-investment-main/lib/store/rentals.ts"
      to: "triple-j-auto-investment-main/services/rentalService.ts"
      via: "service import"
      pattern: "from.*services/rentalService"
    - from: "triple-j-auto-investment-main/context/Store.tsx"
      to: "triple-j-auto-investment-main/lib/store/rentals.ts"
      via: "module import"
      pattern: "from.*lib/store/rentals"
---

<objective>
Create TypeScript types, service layer, and store module for the rental management system.

Purpose: The UI components (Plans 03-06) all depend on having typed data structures, service functions for Supabase operations, and state management wired into the existing Store. This plan creates the entire data plumbing layer.

Output: Types in types.ts, full CRUD service in rentalService.ts, store module in lib/store/rentals.ts, and Store.tsx integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-rental-management-core/06-CONTEXT.md
@.planning/phases/06-rental-management-core/06-RESEARCH.md
@.planning/phases/06-rental-management-core/06-01-SUMMARY.md
@triple-j-auto-investment-main/types.ts
@triple-j-auto-investment-main/services/registrationService.ts
@triple-j-auto-investment-main/lib/store/types.ts
@triple-j-auto-investment-main/lib/store/vehicles.ts
@triple-j-auto-investment-main/lib/store/index.ts
@triple-j-auto-investment-main/context/Store.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rental types to types.ts</name>
  <files>triple-j-auto-investment-main/types.ts</files>
  <action>
Add the following types/interfaces to the END of types.ts (do not modify any existing types):

1. **ListingType** type alias:
   ```typescript
   export type ListingType = 'sale_only' | 'rental_only' | 'both';
   ```

2. **RentalBookingStatus** type alias:
   ```typescript
   export type RentalBookingStatus = 'reserved' | 'active' | 'returned' | 'cancelled' | 'overdue';
   ```

3. **PaymentMethod** type alias:
   ```typescript
   export type PaymentMethod = 'cash' | 'card' | 'zelle' | 'cashapp';
   ```

4. **FuelLevel** type alias:
   ```typescript
   export type FuelLevel = 'empty' | '1/4' | '1/2' | '3/4' | 'full';
   ```

5. **ConditionRating** type alias:
   ```typescript
   export type ConditionRating = 'good' | 'fair' | 'damaged';
   ```

6. **ConditionChecklistItem** interface:
   ```typescript
   export interface ConditionChecklistItem {
     category: string;
     item: string;
     condition: ConditionRating;
     notes: string;
   }
   ```

7. **RentalCustomer** interface:
   - id, fullName, phone, email (optional), driversLicenseNumber, address
   - emergencyContactName (optional), emergencyContactPhone (optional)
   - employerName (optional), employerPhone (optional)
   - notes (optional), createdAt, updatedAt

8. **RentalBooking** interface:
   - id, bookingId, vehicleId, customerId
   - startDate, endDate, actualReturnDate (optional)
   - dailyRate, weeklyRate (optional), totalCost
   - status: RentalBookingStatus
   - agreementSigned, agreementPdfUrl (optional), signatureData (optional)
   - authorizedDrivers: string[]
   - outOfStatePermitted, permittedStates: string[]
   - mileageOut (optional), mileageIn (optional), mileageLimit (optional)
   - lateFeeOverride (optional), lateFeeNotes (optional)
   - notes (optional)
   - createdAt, updatedAt
   - customer?: RentalCustomer (optional join)
   - vehicle?: Vehicle (optional join)
   - payments?: RentalPayment[] (optional join)

9. **RentalPayment** interface:
   - id, bookingId, amount, paymentMethod: PaymentMethod
   - paymentDate, notes (optional), recordedBy (optional), createdAt

10. **RentalConditionReport** interface:
    - id, bookingId, reportType: 'checkout' | 'return'
    - checklistItems: ConditionChecklistItem[]
    - fuelLevel: FuelLevel, mileage
    - photoUrls: string[]
    - completedBy (optional), completedAt, createdAt

11. **CONDITION_CHECKLIST_TEMPLATE** constant:
    An array of ConditionChecklistItem objects with default condition 'good' and empty notes, covering:
    - Exterior (13 items): Front bumper, Rear bumper, Hood, Trunk/Hatch, Roof, Left front fender, Left rear fender, Right front fender, Right rear fender, Windshield, Rear window, Left side windows, Right side windows
    - Interior (8 items): Driver seat, Passenger seat, Rear seats, Dashboard, Steering wheel, Floor mats/carpet, Headliner, Center console
    - Mechanical (6 items): All lights working, Horn, Wipers, AC/Heat, Radio/Infotainment, Spare tire/Jack

12. **PAYMENT_METHOD_LABELS** constant:
    ```typescript
    export const PAYMENT_METHOD_LABELS: Record<PaymentMethod, string> = {
      cash: 'Cash', card: 'Card', zelle: 'Zelle', cashapp: 'CashApp'
    };
    ```

Also update the **Vehicle** interface to add optional rental fields (at the end of the interface, before the closing brace):
- `listingType?: ListingType`
- `dailyRate?: number`
- `weeklyRate?: number`
- `minRentalDays?: number`
- `maxRentalDays?: number`
  </action>
  <verify>Run `npx tsc --noEmit` from the triple-j-auto-investment-main directory. No new type errors should be introduced.</verify>
  <done>All rental-related TypeScript types exist in types.ts. Vehicle interface includes optional rental fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create rentalService.ts and store module</name>
  <files>
    triple-j-auto-investment-main/services/rentalService.ts
    triple-j-auto-investment-main/lib/store/types.ts
    triple-j-auto-investment-main/lib/store/rentals.ts
    triple-j-auto-investment-main/lib/store/index.ts
    triple-j-auto-investment-main/context/Store.tsx
  </files>
  <action>
**A. Create `services/rentalService.ts`** following the exact pattern of registrationService.ts:

1. Import supabase from '../supabase/config' and types from '../types'

2. **Transform functions** (snake_case DB -> camelCase TS):
   - `transformCustomer(data: any): RentalCustomer` -- map all fields
   - `transformBooking(data: any): RentalBooking` -- map all fields, parse JSONB arrays (authorized_drivers, permitted_states), optionally transform nested customer/vehicle/payments if present
   - `transformPayment(data: any): RentalPayment`
   - `transformConditionReport(data: any): RentalConditionReport` -- parse checklist_items and photo_urls JSONB

3. **Booking CRUD**:
   - `getAllBookings(): Promise<RentalBooking[]>` -- select *, order by start_date desc. Include `rental_customers(*)` join and `rental_payments(*)` join via Supabase select syntax: `.select('*, rental_customers(*), rental_payments(*)')`
   - `getBookingById(id: string): Promise<RentalBooking | null>` -- single booking with joins
   - `getBookingsForMonth(year: number, month: number): Promise<RentalBooking[]>` -- WHERE start_date <= month_end AND end_date >= month_start (for calendar view). Month is 0-indexed (JS convention). Calculate month_start as first day, month_end as last day.
   - `getActiveBookings(): Promise<RentalBooking[]>` -- status IN ('reserved', 'active', 'overdue')
   - `createBooking(data: Partial<RentalBooking>): Promise<RentalBooking | null>` -- INSERT with camelCase -> snake_case mapping. Do NOT include booking_id (auto-generated by trigger). Return the created booking.
   - `updateBooking(id: string, data: Partial<RentalBooking>): Promise<boolean>` -- UPDATE with camelCase -> snake_case mapping
   - `cancelBooking(id: string): Promise<boolean>` -- set status to 'cancelled'
   - `returnBooking(id: string, actualReturnDate: string, mileageIn: number): Promise<boolean>` -- set status 'returned', actual_return_date, mileage_in

4. **Customer CRUD**:
   - `getAllCustomers(): Promise<RentalCustomer[]>`
   - `getCustomerById(id: string): Promise<RentalCustomer | null>`
   - `createCustomer(data: Partial<RentalCustomer>): Promise<RentalCustomer | null>`
   - `updateCustomer(id: string, data: Partial<RentalCustomer>): Promise<boolean>`
   - `searchCustomers(query: string): Promise<RentalCustomer[]>` -- ilike on full_name, phone, email, drivers_license_number

5. **Payment functions**:
   - `getPaymentsForBooking(bookingId: string): Promise<RentalPayment[]>`
   - `createPayment(data: { bookingId: string; amount: number; paymentMethod: PaymentMethod; notes?: string; recordedBy?: string }): Promise<RentalPayment | null>`
   - `deletePayment(id: string): Promise<boolean>`

6. **Condition report functions**:
   - `getConditionReports(bookingId: string): Promise<RentalConditionReport[]>`
   - `createConditionReport(data: Partial<RentalConditionReport>): Promise<RentalConditionReport | null>`

7. **Availability functions**:
   - `getAvailableVehicles(startDate: string, endDate: string): Promise<Vehicle[]>` -- Get vehicles with listing_type IN ('rental_only', 'both'), then exclude those with conflicting active bookings (status NOT IN cancelled/returned, date overlap). Uses two queries: all rental vehicles, then conflicting booking vehicle_ids. Filter client-side. Transform vehicles using the Vehicle type.
   - `updateVehicleListingType(vehicleId: string, listingType: ListingType): Promise<boolean>` -- UPDATE vehicles SET listing_type
   - `updateVehicleRentalRates(vehicleId: string, dailyRate: number, weeklyRate?: number, minDays?: number, maxDays?: number): Promise<boolean>`

8. **Utility functions**:
   - `calculateLateFee(endDate: string, actualReturnDate: string | null, dailyRate: number, override: number | null): { amount: number; days: number; isOverridden: boolean }` -- Pure function, no DB call. If override is not null, return override amount. Otherwise compute days past due from endDate to (actualReturnDate or today), multiply by dailyRate.
   - `calculateBookingTotal(startDate: string, endDate: string, dailyRate: number, weeklyRate?: number): number` -- Compute total: if duration >= 7 and weeklyRate exists, use weekly chunks + daily remainder. Otherwise all daily.

**B. Update `lib/store/types.ts`**:
Add after existing exports:
```typescript
import { RentalBooking } from '../../types';

export interface RentalState {
  bookings: RentalBooking[];
  isLoadingRentals: boolean;
}

export interface RentalSetters {
  setBookings: Dispatch<SetStateAction<RentalBooking[]>>;
  setIsLoadingRentals: Dispatch<SetStateAction<boolean>>;
}
```

**C. Create `lib/store/rentals.ts`**:
Follow the exact pattern of vehicles.ts:
- `loadBookings(setters: RentalSetters): Promise<void>` -- calls getAllBookings from rentalService, sets state
- Export the function

**D. Update `lib/store/index.ts`**:
Add re-export: `export { loadBookings } from './rentals';`

**E. Update `context/Store.tsx`**:
1. Import `loadBookings` from lib/store/rentals and `RentalBooking` from types
2. Add state: `const [bookings, setBookings] = useState<RentalBooking[]>([]);` and `const [isLoadingRentals, setIsLoadingRentals] = useState(false);`
3. Add `refreshBookings` wrapper function that calls loadBookings with setters
4. Call `refreshBookings()` in the initial useEffect (alongside loadVehicles/loadLeads)
5. Add `bookings` and `refreshBookings` to StoreContextType interface
6. Add them to the context value object
7. Add them to the useStore destructuring

Keep changes minimal -- just state + wrapper + context exposure. No Supabase realtime subscription for rentals yet (can add later).
  </action>
  <verify>
  Run `npx tsc --noEmit` from the triple-j-auto-investment-main directory. The build should pass with no new errors. Verify that Store.tsx exports `bookings` and `refreshBookings` in its context type.
  </verify>
  <done>
  rentalService.ts exists with full CRUD, transformer, and utility functions. Store.tsx exposes bookings state and refreshBookings. lib/store/rentals.ts follows established extraction pattern. Build passes.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no new errors
- types.ts contains RentalBooking, RentalCustomer, RentalPayment, RentalConditionReport
- Vehicle interface has listingType, dailyRate, weeklyRate fields
- rentalService.ts follows transformRegistration pattern (snake_case -> camelCase)
- Store.tsx exposes bookings and refreshBookings
- lib/store/rentals.ts follows vehicles.ts extraction pattern
</verification>

<success_criteria>
- All rental TypeScript types defined and exported
- Service layer provides full CRUD for bookings, customers, payments, condition reports
- Availability query correctly filters by listing_type and date overlap
- Late fee calculation is a pure function (no DB dependency)
- Store integrates rental state via existing facade pattern
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-rental-management-core/06-02-SUMMARY.md`
</output>
